
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pulse Arrival Time &#8212; Signal Processing and Learning for Wearables</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script >const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Pulse Wave Analysis" href="pulse-wave-analysis.html" />
    <link rel="prev" title="Beat detection" href="beat-detection.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/icon.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Signal Processing and Learning for Wearables</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Introduction
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../overview.html">
   Overview
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../overview/aims.html">
     Aims
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../overview/workshop-2023-03.html">
     Workshop - March 2023
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../background.html">
   Background
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../background/wearables.html">
     Wearable Devices
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../background/signals.html">
     Signals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../background/physiology.html">
     Physiology
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../background/applications.html">
     Applications
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../resources.html">
   Resources
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../resources/data.html">
     Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../resources/code.html">
     Code
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../../tutorials.html">
   Tutorials
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="data-exploration2.html">
     Exploring PTT-PPG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="data-exploration.html">
     Exploring MIMIC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="signal-filtering.html">
     Filtering Signals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="beat-detection.html">
     Beat detection
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Pulse Arrival Time
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="pulse-wave-analysis.html">
     Pulse Wave Analysis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="extracting-reference-bp.html">
     Extracting BP values
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../case-studies.html">
   Case Studies
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../case-studies/bp-estimation.html">
     Cuffless Blood Pressure
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../summary.html">
   Summary
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../closing/additional-resources.html">
     Additional Resources
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../about.html">
   About
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../about/about-contributing.html">
     Contributing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../about/about-maintenance.html">
     Maintenance
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="../../about/future-tutorials.html">
     Future Tutorials
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="qrs-detection.html">
       QRS peak detection
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../signal-quality-assessment.html">
       Signal Quality Assessment
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../data-modelling.html">
       Data modelling
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../data-analysis.html">
       Data analysis
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="../data-interpretation.html">
       Data interpretation
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../about/acknowledgment.html">
     Acknowledgment
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/tutorial/notebooks/pulse-arrival-time.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/peterhcharlton/bsp-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/peterhcharlton/bsp-book/issues/new?title=Issue%20on%20page%20%2Ftutorial/notebooks/pulse-arrival-time.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/peterhcharlton/bsp-book/edit/main/content/tutorial/notebooks/pulse-arrival-time.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/peterhcharlton/bsp-book/main?urlpath=tree/content/tutorial/notebooks/pulse-arrival-time.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/peterhcharlton/bsp-book/blob/main/content/tutorial/notebooks/pulse-arrival-time.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Launch Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="../../_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#setup">
   Setup
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extract-one-minute-of-signals-from-this-segment">
   Extract one minute of signals from this segment
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#filter-the-signals">
   Filter the signals
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#beat-detection-for-pulsatile-signals">
   Beat detection for pulsatile signals
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     Setup
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#detect-beats-in-the-ppg-signal">
     Detect beats in the PPG signal
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#detect-beats-in-the-ecg-signal">
     Detect beats in the ECG signal
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#plot-the-results">
     Plot the results
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#identifying-fiducial-points">
   Identifying fiducial points
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#calculate-pulse-arrival-time">
   Calculate pulse arrival time
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#functions">
   Functions
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="pulse-arrival-time">
<h1>Pulse Arrival Time<a class="headerlink" href="#pulse-arrival-time" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial we will learn how to estimate pulse arrival time from ECG and PPG signals.</p>
<p>Our <strong>objectives</strong> are to:</p>
<ul class="simple">
<li><p>Be able to identify relevant points on ECG and PPG signals</p></li>
<li><p>Extract pulse arrival time from these points</p></li>
<li><p>Be aware of the variability inherent in real-world data</p></li>
</ul>
<div class="alert alert-block alert-warning"><p><b>Context:</b> A key step in analysing PPG and BP signals is the detection of beats in the signals. This allows individual pulse waves to be analysed, and either: (i) features to be extracted from PPG pulse waves; or (ii) reference BP values to be extracted from BP pulse waves.</p></div><hr class="docutils" />
<div class="section" id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h2>
<p><em>These steps have been covered in previous tutorials, so we’ll just re-use the code here.</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Packages</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="o">!</span>pip install <span class="nv">wfdb</span><span class="o">==</span><span class="m">4</span>.1.0
<span class="kn">import</span> <span class="nn">wfdb</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: wfdb==4.1.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (4.1.0)
Requirement already satisfied: numpy&lt;2.0.0,&gt;=1.10.1 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (1.20.1)
Requirement already satisfied: requests&lt;3.0.0,&gt;=2.8.1 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (2.25.1)
Requirement already satisfied: pandas&lt;2.0.0,&gt;=1.0.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (1.2.4)
Requirement already satisfied: scipy&lt;2.0.0,&gt;=1.0.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (1.6.2)
Requirement already satisfied: SoundFile&lt;0.12.0,&gt;=0.10.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (0.10.3.post1)
Requirement already satisfied: matplotlib&lt;4.0.0,&gt;=3.2.2 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from wfdb==4.1.0) (3.3.4)
Requirement already satisfied: pillow&gt;=6.2.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (8.2.0)
Requirement already satisfied: kiwisolver&gt;=1.0.1 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (1.3.1)
Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,&gt;=2.0.3 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (2.4.7)
Requirement already satisfied: python-dateutil&gt;=2.1 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (2.8.1)
Requirement already satisfied: cycler&gt;=0.10 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (0.10.0)
Requirement already satisfied: six in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from cycler&gt;=0.10-&gt;matplotlib&lt;4.0.0,&gt;=3.2.2-&gt;wfdb==4.1.0) (1.15.0)
Requirement already satisfied: pytz&gt;=2017.3 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from pandas&lt;2.0.0,&gt;=1.0.0-&gt;wfdb==4.1.0) (2021.1)
Requirement already satisfied: chardet&lt;5,&gt;=3.0.2 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from requests&lt;3.0.0,&gt;=2.8.1-&gt;wfdb==4.1.0) (4.0.0)
Requirement already satisfied: urllib3&lt;1.27,&gt;=1.21.1 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from requests&lt;3.0.0,&gt;=2.8.1-&gt;wfdb==4.1.0) (1.26.4)
Requirement already satisfied: certifi&gt;=2017.4.17 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from requests&lt;3.0.0,&gt;=2.8.1-&gt;wfdb==4.1.0) (2022.12.7)
Requirement already satisfied: idna&lt;3,&gt;=2.5 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from requests&lt;3.0.0,&gt;=2.8.1-&gt;wfdb==4.1.0) (2.10)
Requirement already satisfied: cffi&gt;=1.0 in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from SoundFile&lt;0.12.0,&gt;=0.10.0-&gt;wfdb==4.1.0) (1.14.5)
Requirement already satisfied: pycparser in /Users/petercharlton/anaconda3/lib/python3.8/site-packages (from cffi&gt;=1.0-&gt;SoundFile&lt;0.12.0,&gt;=0.10.0-&gt;wfdb==4.1.0) (2.20)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The name of the MIMIC IV Waveform Database on PhysioNet</span>
<span class="n">database_name</span> <span class="o">=</span> <span class="s1">&#39;mimic4wdb/0.1.0&#39;</span> 

<span class="c1"># Segment for analysis</span>
<span class="n">segment_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;83404654_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;82924339_0007&#39;</span><span class="p">,</span> <span class="s1">&#39;84248019_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;82439920_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;82800131_0002&#39;</span><span class="p">,</span> <span class="s1">&#39;84304393_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;89464742_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;88958796_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;88995377_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;85230771_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;86643930_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;81250824_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;87706224_0003&#39;</span><span class="p">,</span> <span class="s1">&#39;83058614_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;82803505_0017&#39;</span><span class="p">,</span> <span class="s1">&#39;88574629_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;87867111_0012&#39;</span><span class="p">,</span> <span class="s1">&#39;84560969_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;87562386_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;88685937_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;86120311_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;89866183_0014&#39;</span><span class="p">,</span> <span class="s1">&#39;89068160_0002&#39;</span><span class="p">,</span> <span class="s1">&#39;86380383_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;85078610_0008&#39;</span><span class="p">,</span> <span class="s1">&#39;87702634_0007&#39;</span><span class="p">,</span> <span class="s1">&#39;84686667_0002&#39;</span><span class="p">,</span> <span class="s1">&#39;84802706_0002&#39;</span><span class="p">,</span> <span class="s1">&#39;81811182_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;84421559_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;88221516_0007&#39;</span><span class="p">,</span> <span class="s1">&#39;80057524_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;84209926_0018&#39;</span><span class="p">,</span> <span class="s1">&#39;83959636_0010&#39;</span><span class="p">,</span> <span class="s1">&#39;89989722_0016&#39;</span><span class="p">,</span> <span class="s1">&#39;89225487_0007&#39;</span><span class="p">,</span> <span class="s1">&#39;84391267_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;80889556_0002&#39;</span><span class="p">,</span> <span class="s1">&#39;85250558_0011&#39;</span><span class="p">,</span> <span class="s1">&#39;84567505_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;85814172_0007&#39;</span><span class="p">,</span> <span class="s1">&#39;88884866_0005&#39;</span><span class="p">,</span> <span class="s1">&#39;80497954_0012&#39;</span><span class="p">,</span> <span class="s1">&#39;80666640_0014&#39;</span><span class="p">,</span> <span class="s1">&#39;84939605_0004&#39;</span><span class="p">,</span> <span class="s1">&#39;82141753_0018&#39;</span><span class="p">,</span> <span class="s1">&#39;86874920_0014&#39;</span><span class="p">,</span> <span class="s1">&#39;84505262_0010&#39;</span><span class="p">,</span> <span class="s1">&#39;86288257_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;89699401_0001&#39;</span><span class="p">,</span> <span class="s1">&#39;88537698_0013&#39;</span><span class="p">,</span> <span class="s1">&#39;83958172_0001&#39;</span><span class="p">]</span>
<span class="n">segment_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mimic4wdb/0.1.0/waves/p100/p10020306/83404654&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p101/p10126957/82924339&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p102/p10209410/84248019&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p109/p10952189/82439920&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p111/p11109975/82800131&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p113/p11392990/84304393&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p121/p12168037/89464742&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p121/p12173569/88958796&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p121/p12188288/88995377&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p128/p12872596/85230771&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p129/p12933208/86643930&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p130/p13016481/81250824&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p132/p13240081/87706224&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p136/p13624686/83058614&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p137/p13791821/82803505&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p141/p14191565/88574629&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p142/p14285792/87867111&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p143/p14356077/84560969&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p143/p14363499/87562386&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p146/p14695840/88685937&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p149/p14931547/86120311&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p151/p15174162/89866183&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p153/p15312343/89068160&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p153/p15342703/86380383&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p155/p15552902/85078610&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p156/p15649186/87702634&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p158/p15857793/84686667&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p158/p15865327/84802706&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p158/p15896656/81811182&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p159/p15920699/84421559&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p160/p16034243/88221516&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p165/p16566444/80057524&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p166/p16644640/84209926&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p167/p16709726/83959636&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p167/p16715341/89989722&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p168/p16818396/89225487&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p170/p17032851/84391267&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p172/p17229504/80889556&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p173/p17301721/85250558&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p173/p17325001/84567505&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p174/p17490822/85814172&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p177/p17738824/88884866&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p177/p17744715/80497954&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p179/p17957832/80666640&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p180/p18080257/84939605&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p181/p18109577/82141753&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p183/p18324626/86874920&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p187/p18742074/84505262&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p188/p18824975/86288257&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p191/p19126489/89699401&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p193/p19313794/88537698&#39;</span><span class="p">,</span> <span class="s1">&#39;mimic4wdb/0.1.0/waves/p196/p19619764/83958172&#39;</span><span class="p">]</span>

<span class="c1"># 3 and 8 are helpful</span>
<span class="n">rel_segment_no</span> <span class="o">=</span> <span class="mi">8</span> 
<span class="n">rel_segment_name</span> <span class="o">=</span> <span class="n">segment_names</span><span class="p">[</span><span class="n">rel_segment_no</span><span class="p">]</span>
<span class="n">rel_segment_dir</span> <span class="o">=</span> <span class="n">segment_dirs</span><span class="p">[</span><span class="n">rel_segment_no</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="extract-one-minute-of-signals-from-this-segment">
<h2>Extract one minute of signals from this segment<a class="headerlink" href="#extract-one-minute-of-signals-from-this-segment" title="Permalink to this headline">¶</a></h2>
<p><em>These steps have been covered in previous tutorials, so we’ll just re-use the code here.</em></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># time since the start of the segment at which to begin extracting data</span>
<span class="n">start_seconds</span> <span class="o">=</span> <span class="mi">100</span> 
<span class="n">no_seconds_to_load</span> <span class="o">=</span> <span class="mi">60</span>

<span class="n">segment_metadata</span> <span class="o">=</span> <span class="n">wfdb</span><span class="o">.</span><span class="n">rdheader</span><span class="p">(</span><span class="n">record_name</span><span class="o">=</span><span class="n">rel_segment_name</span><span class="p">,</span> <span class="n">pn_dir</span><span class="o">=</span><span class="n">rel_segment_dir</span><span class="p">)</span> 
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Metadata loaded from segment: </span><span class="si">{</span><span class="n">rel_segment_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">fs</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">segment_metadata</span><span class="o">.</span><span class="n">fs</span><span class="p">)</span>
<span class="n">sampfrom</span> <span class="o">=</span> <span class="n">fs</span><span class="o">*</span><span class="n">start_seconds</span>
<span class="n">sampto</span> <span class="o">=</span> <span class="n">fs</span><span class="o">*</span><span class="p">(</span><span class="n">start_seconds</span><span class="o">+</span><span class="n">no_seconds_to_load</span><span class="p">)</span>

<span class="n">segment_data</span> <span class="o">=</span> <span class="n">wfdb</span><span class="o">.</span><span class="n">rdrecord</span><span class="p">(</span><span class="n">record_name</span><span class="o">=</span><span class="n">rel_segment_name</span><span class="p">,</span>
                             <span class="n">sampfrom</span><span class="o">=</span><span class="n">sampfrom</span><span class="p">,</span>
                             <span class="n">sampto</span><span class="o">=</span><span class="n">sampto</span><span class="p">,</span>
                             <span class="n">pn_dir</span><span class="o">=</span><span class="n">rel_segment_dir</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">no_seconds_to_load</span><span class="si">}</span><span class="s2"> seconds of data extracted from: </span><span class="si">{</span><span class="n">rel_segment_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">abp_col</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ppg_col</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">abp_col</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">sig_name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;ABP&#39;</span><span class="p">)</span>
<span class="n">ppg_col</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">sig_name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Pleth&#39;</span><span class="p">)</span>
<span class="n">ecg_col</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">sig_name</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;II&#39;</span><span class="p">)</span>

<span class="n">abp</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">p_signal</span><span class="p">[:,</span><span class="n">abp_col</span><span class="p">]</span>
<span class="n">ppg</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">p_signal</span><span class="p">[:,</span><span class="n">ppg_col</span><span class="p">]</span>
<span class="n">ecg</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">p_signal</span><span class="p">[:,</span><span class="n">ecg_col</span><span class="p">]</span>
<span class="n">fs</span> <span class="o">=</span> <span class="n">segment_data</span><span class="o">.</span><span class="n">fs</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted the ABP signal from column </span><span class="si">{</span><span class="n">abp_col</span><span class="si">}</span><span class="s2"> of the matrix of waveform data at </span><span class="si">{</span><span class="n">fs</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Hz.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted the PPG signal from column </span><span class="si">{</span><span class="n">ppg_col</span><span class="si">}</span><span class="s2"> of the matrix of waveform data at </span><span class="si">{</span><span class="n">fs</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Hz.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extracted the ECG signal from column </span><span class="si">{</span><span class="n">ecg_col</span><span class="si">}</span><span class="s2"> of the matrix of waveform data at </span><span class="si">{</span><span class="n">fs</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> Hz.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Metadata loaded from segment: 88995377_0001
60 seconds of data extracted from: 88995377_0001
Extracted the ABP signal from column 3 of the matrix of waveform data at 62.5 Hz.
Extracted the PPG signal from column 4 of the matrix of waveform data at 62.5 Hz.
Extracted the ECG signal from column 2 of the matrix of waveform data at 62.5 Hz.
</pre></div>
</div>
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="filter-the-signals">
<h2>Filter the signals<a class="headerlink" href="#filter-the-signals" title="Permalink to this headline">¶</a></h2>
<p><em>These steps have been covered in previous tutorials, so we’ll just re-use the code here.</em></p>
<ul class="simple">
<li><p>Import packages</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Create filter for PPG and BP</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># filter cut-offs for PPG and BP</span>
<span class="n">lpf_cutoff</span> <span class="o">=</span> <span class="mf">0.7</span> <span class="c1"># Hz</span>
<span class="n">hpf_cutoff</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># Hz</span>

<span class="c1"># create filter</span>
<span class="n">sos_filter</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="n">lpf_cutoff</span><span class="p">,</span> <span class="n">hpf_cutoff</span><span class="p">],</span>
                       <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bp&#39;</span><span class="p">,</span>
                       <span class="n">analog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;sos&#39;</span><span class="p">,</span>
                       <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Filter PPG and BP</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># filter PPG</span>
<span class="n">ppg_filt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_filter</span><span class="p">,</span> <span class="n">ppg</span><span class="p">)</span>

<span class="c1"># Filter ABP</span>
<span class="n">abp_filt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_filter</span><span class="p">,</span> <span class="n">abp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Plot the results</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg</span><span class="p">))</span><span class="o">/</span><span class="n">fs</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;PPG&#39;)
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_18_1.png" src="../../_images/pulse-arrival-time_18_1.png" />
</div>
</div>
<ul class="simple">
<li><p>Create filter for ECG</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># filter cut-offs for PPG and BP</span>
<span class="n">lpf_cutoff</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># Hz</span>
<span class="n">hpf_cutoff</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1"># Hz</span>

<span class="c1"># create filter</span>
<span class="n">sos_filter</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="n">lpf_cutoff</span><span class="p">,</span> <span class="n">hpf_cutoff</span><span class="p">],</span>
                       <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bp&#39;</span><span class="p">,</span>
                       <span class="n">analog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;sos&#39;</span><span class="p">,</span>
                       <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Filter ECG</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ecg_filt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos_filter</span><span class="p">,</span> <span class="n">ecg</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Plot the results</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ecg</span><span class="p">))</span><span class="o">/</span><span class="n">fs</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ecg</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ecg_filt</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude [V]&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Amplitude [V]&#39;)
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_24_1.png" src="../../_images/pulse-arrival-time_24_1.png" />
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="beat-detection-for-pulsatile-signals">
<h2>Beat detection for pulsatile signals<a class="headerlink" href="#beat-detection-for-pulsatile-signals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Setup<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Import the functions required to detect beats by running the cell containing the required functions <a class="reference external" href="#functions">below</a>.</p></li>
</ul>
<div class="alert alert-block alert-info"><p><b>Question:</b> How have these functions been stored?</p></div></div>
<div class="section" id="detect-beats-in-the-ppg-signal">
<h3>Detect beats in the PPG signal<a class="headerlink" href="#detect-beats-in-the-ppg-signal" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Detect beats in the PPG signal using three beat detector algorithms:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">pulse_detect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Placeholder for a pulse detection function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Override the pulse_detect function with the example </span>
<span class="s2">          provided at the bottom of this notebook.</span><span class="se">\n</span><span class="s2">&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ppg_ibis_d2max</span> <span class="o">=</span> <span class="n">pulse_detect</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;d2max&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_ibis_d2max</span><span class="p">)</span><span class="si">}</span><span class="s2"> beats in the PPG signal using the </span><span class="si">{</span><span class="s1">&#39;D2max&#39;</span><span class="si">}</span><span class="s2"> algorithm&quot;</span><span class="p">)</span>

<span class="n">ppg_ibis_upslopes</span> <span class="o">=</span> <span class="n">pulse_detect</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="s1">&#39;upslopes&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_ibis_upslopes</span><span class="p">)</span><span class="si">}</span><span class="s2"> beats in the PPG signal using the </span><span class="si">{</span><span class="s1">&#39;Upslopes&#39;</span><span class="si">}</span><span class="s2"> algorithm&quot;</span><span class="p">)</span>

<span class="n">ppg_ibis_delineator</span> <span class="o">=</span> <span class="n">pulse_detect</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;delineator&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_ibis_delineator</span><span class="p">)</span><span class="si">}</span><span class="s2"> beats in the PPG signal using the </span><span class="si">{</span><span class="s1">&#39;Delineator&#39;</span><span class="si">}</span><span class="s2"> algorithm&quot;</span><span class="p">)</span>

<span class="c1">#ppg_ibis_qppg = pulse_detect(ppg_filt, fs, 10, &#39;qppg&#39;)</span>
<span class="c1">#print(f&quot;Detected {len(ppg_ibis_qppg)} beats in the PPG signal using the {&#39;qppg&#39;} algorithm&quot;)</span>

<span class="n">ppg_ibis_bishop</span> <span class="o">=</span> <span class="n">pulse_detect</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;bishop&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_ibis_bishop</span><span class="p">)</span><span class="si">}</span><span class="s2"> beats in the PPG signal using the </span><span class="si">{</span><span class="s1">&#39;bishop&#39;</span><span class="si">}</span><span class="s2"> algorithm&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Detected 82 beats in the PPG signal using the D2max algorithm
Detected 82 beats in the PPG signal using the Upslopes algorithm
Detected 82 beats in the PPG signal using the Delineator algorithm
Detected 82 beats in the PPG signal using the bishop algorithm
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Plot the results:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">,</span><span class="n">ax3</span><span class="p">,</span><span class="n">ax4</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">sharex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="n">sharey</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;IBIs detection&#39;</span><span class="p">)</span> 

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span><span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_d2max</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_d2max</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [V]&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;D2Max&#39;</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_upslopes</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_upslopes</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [V]&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Upslopes&#39;</span><span class="p">)</span>

<span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_delineator</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_delineator</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [V]&#39;</span><span class="p">)</span>
<span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Delineator&#39;</span><span class="p">)</span>

<span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax4</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_bishop</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_bishop</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [V]&#39;</span><span class="p">)</span>
<span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Bishop&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Bishop&#39;)
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_34_1.png" src="../../_images/pulse-arrival-time_34_1.png" />
</div>
</div>
<p>We’ll use the ‘Bishop’ algorithm in the rest of this tutorial</p>
<div class="alert alert-block alert-info"><p><b>Task:</b> Try repeating this for 'rel_segment_no = 3' How do the beat detectors perform on this patient's data?</p></div></div>
<div class="section" id="detect-beats-in-the-ecg-signal">
<h3>Detect beats in the ECG signal<a class="headerlink" href="#detect-beats-in-the-ecg-signal" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># based on: https://neuropsychology.github.io/NeuroKit/studies/ecg_benchmark.html</span>

<span class="kn">import</span> <span class="nn">neurokit2</span> <span class="k">as</span> <span class="nn">nk</span>

<span class="n">signals</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">nk</span><span class="o">.</span><span class="n">ecg_peaks</span><span class="p">(</span><span class="n">ecg_filt</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mf">62.5</span><span class="p">,</span> <span class="n">correct_artifacts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">ecg_ibis</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;ECG_R_Peaks&quot;</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Detected </span><span class="si">{}</span><span class="s2"> beats in the ECG signal using the </span><span class="si">{}</span><span class="s2"> algorithm&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ecg_ibis</span><span class="p">),</span> <span class="s2">&quot;neurokit&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Detected 93 beats in the ECG signal using the neurokit algorithm
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/petercharlton/anaconda3/lib/python3.8/site-packages/neurokit2/signal/signal_fixpeaks.py:277: RuntimeWarning: divide by zero encountered in true_divide
  mrrs /= th2
/Users/petercharlton/anaconda3/lib/python3.8/site-packages/neurokit2/signal/signal_fixpeaks.py:277: RuntimeWarning: invalid value encountered in true_divide
  mrrs /= th2
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="plot-the-results">
<h3>Plot the results<a class="headerlink" href="#plot-the-results" title="Permalink to this headline">¶</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">sharex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">sharey</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Beat detection&#39;</span><span class="p">)</span> 

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span><span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_bishop</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_bishop</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [au]&#39;</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ecg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ecg_ibis</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ecg_filt</span><span class="p">[</span><span class="n">ecg_ibis</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time [s]&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;ECG&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;ECG&#39;)
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_40_1.png" src="../../_images/pulse-arrival-time_40_1.png" />
</div>
</div>
</div>
</div>
<div class="section" id="identifying-fiducial-points">
<h2>Identifying fiducial points<a class="headerlink" href="#identifying-fiducial-points" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Extract R-waves from the ECG: <em>This is straightforward because the ECG beat detection algorithm provides R-wave indices.</em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="n">r_waves</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ecg_ibis</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Extract pulse onsets from the PPG: <em>PPG beat detection algorithms usually provide indices of PPG pulse peaks, which are not ideal for pulse arrival time estimation. Instead, we will extract indices of pulse onsets:</em></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Find all the local minima (troughs) in the PPG signal</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">signal</span>
<span class="n">minima</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">argrelmin</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Find the pulse onset corresponding to each PPG pulse peak (by assuming that the local minimum immediately preceeding the pulse peak is the pulse onset)</span>

<span class="c1"># - We&#39;ll use a function to find the index in a list which immediately preceeds a point</span>
<span class="k">def</span> <span class="nf">find_previous</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">array</span> <span class="o">-</span> <span class="n">value</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">diffs</span><span class="p">,</span> <span class="o">-</span><span class="mi">100000</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="c1"># - Find pulse onsets</span>
<span class="n">onsets</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_ibis_bishop</span><span class="p">)):</span>
    <span class="n">onsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">find_previous</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">ppg_ibis_bishop</span><span class="p">[</span><span class="n">no</span><span class="p">]))</span>
<span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p>Plot the results</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ppg_filt</span><span class="p">)</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span><span class="mf">1.0</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ppg_filt</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ppg_ibis_bishop</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">ppg_ibis_bishop</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;peaks&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">onsets</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span>
            <span class="n">ppg_filt</span><span class="p">[</span><span class="n">onsets</span><span class="p">],</span>
            <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;onsets&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;PPG [au]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fb8e1cea490&gt;
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_47_1.png" src="../../_images/pulse-arrival-time_47_1.png" />
</div>
</div>
</div>
<div class="section" id="calculate-pulse-arrival-time">
<h2>Calculate pulse arrival time<a class="headerlink" href="#calculate-pulse-arrival-time" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Now we’ll calculate the pulse arrival time as the time delay between each R-wave and the subsequent pulse onset.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># A function to find the index in a list which immediately follows a point</span>
<span class="k">def</span> <span class="nf">find_next</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">array</span> <span class="o">-</span> <span class="n">value</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">diffs</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">diffs</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="c1"># - Find relevant pulse onset for each R-wave</span>
<span class="n">rel_onsets</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">rel_r_wave_inds</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">r_waves</span><span class="p">)):</span>
    <span class="n">curr_onset</span> <span class="o">=</span> <span class="n">find_next</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">r_waves</span><span class="p">[</span><span class="n">no</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">curr_onset</span> <span class="o">&gt;</span> <span class="n">r_waves</span><span class="p">[</span><span class="n">no</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curr_onset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">r_waves</span><span class="p">[</span><span class="n">no</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">fs</span><span class="p">):</span>
        <span class="n">rel_onsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_onset</span><span class="p">)</span>
        <span class="n">rel_r_wave_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>

<span class="n">pat</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">rel_onsets</span> <span class="o">-</span> <span class="n">r_waves</span><span class="p">[</span><span class="n">rel_r_wave_inds</span><span class="p">])</span><span class="o">/</span><span class="n">fs</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;PAT [ms]&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Beat no.&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note that PATs were only provided for </span><span class="si">{}</span><span class="s1"> out of </span><span class="si">{}</span><span class="s1"> beats&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_waves</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Note that PATs were only provided for 82 out of 93 beats
</pre></div>
</div>
<img alt="../../_images/pulse-arrival-time_51_1.png" src="../../_images/pulse-arrival-time_51_1.png" />
</div>
</div>
</div>
<hr class="docutils" />
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<p>The following functions are required for this tutorial. Run the cell below and then return to the top of the page.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">pulse_detect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="n">alg</span><span class="p">,</span><span class="n">vis</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description: Pulse detection and correction from pulsatile signals</span>
<span class="sd">    Inputs:  x, array with pulsatile signal [user defined units]</span>
<span class="sd">             fs, sampling rate of signal [Hz]</span>
<span class="sd">             w, window length for analysis [s]</span>
<span class="sd">             alg, string with the name of the algorithm to apply [&#39;heartpy&#39;,&#39;d2max&#39;,&#39;upslopes&#39;,&#39;delineator&#39;,&#39;qppg&#39;,&#39;bishop&#39;]</span>
<span class="sd">             vis, visualisation option [True, False]</span>
<span class="sd">    Outputs: ibis, location of cardiac cycles as detected by the selected algorithm [number of samples]</span>
<span class="sd">    </span>
<span class="sd">    Algorithms:       1: HeartPy (van Gent et al, 2019, DOI: 10.1016/j.trf.2019.09.015)</span>
<span class="sd">                      2: 2nd derivative maxima (Elgendi et al, 2013, DOI: 10.1371/journal.pone.0076585)</span>
<span class="sd">                      3: Systolic upslopes (Arguello Prada and Serna Maldonado, 2018, </span>
<span class="sd">                         DOI: 10.1080/03091902.2019.1572237)</span>
<span class="sd">                      4: Delineator (Li et al, 2010, DOI: 10.1109/TBME.2005.855725)</span>
<span class="sd">                      5: qppg (Vest et al, 2010, DOI: 10.1088/1361-6579/aae021)</span>
<span class="sd">                      6: Bishop (Bishop and Ercole, 2018, DOI: 10.1007/978-3-319-65798-1_39)</span>
<span class="sd">    Fiducial points:  1: Systolic peak (pks)</span>
<span class="sd">                      2: Onset, as the minimum before the systolic peak (ons)</span>
<span class="sd">                      3: Onset, using the tangent intersection method (ti) </span>
<span class="sd">                      4: Diastolic peak (dpk)</span>
<span class="sd">                      5: Maximum slope (m1d)</span>
<span class="sd">                      6: a point from second derivative PPG (a2d)</span>
<span class="sd">                      7: b point from second derivative PPG (b2d)</span>
<span class="sd">                      8: c point from second derivative PPG (c2d)</span>
<span class="sd">                      9: d point from second derivative PPG (d2d)</span>
<span class="sd">                      10: e point from second derivative PPG (e2d)</span>
<span class="sd">                      11: p1 from the third derivative PPG (p1)    </span>
<span class="sd">                      12: p2 from the third derivative PPG (p2)</span>
<span class="sd">    </span>
<span class="sd">    Libraries: NumPy (as np), SciPy (Signal, as sp), Matplotlib (PyPlot, as plt)</span>
<span class="sd">    </span>
<span class="sd">    Version: 1.0 - June 2022</span>
<span class="sd">             2.0 - July 2022: Bug corrections</span>
<span class="sd">             2.1 - March 2023: Peter Charlton additional beat detectors</span>
<span class="sd">    </span>
<span class="sd">    Developed by: Elisa Mejía-Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Check selected algorithm</span>
    <span class="n">pos_alg</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;heartpy&#39;</span><span class="p">,</span><span class="s1">&#39;d2max&#39;</span><span class="p">,</span><span class="s1">&#39;upslopes&#39;</span><span class="p">,</span><span class="s1">&#39;delineator&#39;</span><span class="p">,</span><span class="s1">&#39;qppg&#39;</span><span class="p">,</span><span class="s1">&#39;bishop&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">alg</span> <span class="ow">in</span> <span class="n">pos_alg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unknown algorithm determined. Using D2max as default&#39;</span><span class="p">)</span>
        <span class="n">alg</span> <span class="o">=</span> <span class="s1">&#39;d2max&#39;</span>
    
    <span class="c1"># Pre-processing of signal</span>
    <span class="n">x_d</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bp&#39;</span><span class="p">,</span> <span class="n">analog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">x_f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x_d</span><span class="p">)</span>
    
    <span class="c1"># Peak detection in windows of length w</span>
    <span class="n">n_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_f</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_int</span><span class="p">)):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">fs</span><span class="o">*</span><span class="n">w</span><span class="p">)</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fs</span><span class="o">*</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">#print(&#39;Start: &#39; + str(start) + &#39;, stop: &#39; + str(stop))</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">x_f</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;heartpy&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">heartpy</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;d2max&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">d2max</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;upslopes&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">upslopes</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;delineator&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">delineator</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>  
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;qppg&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">qppg</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>      
        <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;bishop&#39;</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">bishop</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>     
        <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">+</span> <span class="n">start</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ibis</span> <span class="o">=</span> <span class="n">locs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ibis</span><span class="p">,</span><span class="n">locs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_int</span><span class="o">*</span><span class="n">fs</span><span class="o">*</span><span class="n">w</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_f</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_f</span><span class="p">)</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">x_f</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;heartpy&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">heartpy</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">180</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;d2max&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">d2max</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;upslopes&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">upslopes</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;delineator&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">delineator</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span> 
            <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;qppg&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">qppg</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span><span class="n">fs</span><span class="p">)</span>     
            <span class="k">elif</span> <span class="n">alg</span> <span class="o">==</span> <span class="s1">&#39;bishop&#39;</span><span class="p">:</span>
                <span class="n">locs</span> <span class="o">=</span> <span class="n">bishop</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>        
            <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">+</span> <span class="n">start</span>
            <span class="n">ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ibis</span><span class="p">,</span><span class="n">locs</span><span class="p">)</span>
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibis</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_f</span><span class="p">))</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">ibis</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    
        
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ibis</span><span class="p">)</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">ibis</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">peak_correction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">ibis</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">5</span><span class="p">,[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span><span class="n">vis</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sharey</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Peak detection&#39;</span><span class="p">)</span>
        
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">ibis</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">ibis</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Samples&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude [V]&#39;</span><span class="p">)</span>
        
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_f</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">ibis</span><span class="p">,</span> <span class="n">x_f</span><span class="p">[</span><span class="n">ibis</span><span class="p">],</span> <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Samples&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude [V]&#39;</span><span class="p">)</span>
            
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">peak_correction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">locs</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">stride</span><span class="p">,</span><span class="n">th_len</span><span class="p">,</span><span class="n">vis</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Correction of peaks detected from pulsatile signals</span>
<span class="sd">    </span>
<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">              locs, location of the detected interbeat intervals [number of samples]</span>
<span class="sd">              fs, sampling rate [Hz]</span>
<span class="sd">              t, duration of intervals for the correction [s]</span>
<span class="sd">              stride, stride between consecutive intervals for the correction [s]</span>
<span class="sd">              th_len, array with the percentage of lower and higher thresholds for comparing the duration of IBIs </span>
<span class="sd">              [proportions] </span>
<span class="sd">              vis, visualisation option [True, False]</span>
<span class="sd">    Outputs:  ibis, array with the corrected points related to the start of the inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">                   2.0 -   July 2022: Bug corrections</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span><span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Original&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Peak correction&#39;</span><span class="p">)</span>
            
    <span class="c1"># Correction of long and short IBIs</span>
    <span class="n">aux_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">len_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    <span class="c1">#print(&#39;Window length: &#39; + str(len_window))</span>
    <span class="n">first_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">second_i</span> <span class="o">=</span> <span class="n">len_window</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># check whether the input signal was long enough for this step (added by PC, 20230309)</span>
    <span class="k">if</span> <span class="n">second_i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input signal not long enough for peak correction&#39;</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">second_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;=</span> <span class="n">first_i</span><span class="p">)</span>
        <span class="n">ind2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&lt;=</span> <span class="n">second_i</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>
        
        <span class="n">win</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
        <span class="c1">#print(&#39;Indices: &#39; + str(ind) + &#39;, locs: &#39; + str(locs[ind]) + &#39;, dif: &#39; + str(dif))</span>
        
        <span class="c1"># Correction of repeated IBIs</span>
        <span class="n">ind_zeros</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1">#print(ind_zeros, dif[ind_zeros], dif)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_zeros</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#print(&#39;entro!&#39; + str(dif) + &#39;,&#39; + str(ind_zeros))</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dif</span><span class="p">,</span> <span class="n">ind_zeros</span><span class="p">)</span>
            <span class="c1">#print(dif)</span>
        
        <span class="n">th_dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">th_dif</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">th_len</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dif</span><span class="p">)</span>
        <span class="n">th_dif</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">th_len</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dif</span><span class="p">)</span>
        
        <span class="n">th_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">th_amp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.75</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
        <span class="n">th_amp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
        <span class="c1">#print(&#39;Length thresholds: &#39; + str(th_dif) + &#39;, amplitude thresholds: &#39; + str(th_amp))</span>
        
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dif</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dif</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">th_dif</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1">#print(&#39;IBI pos &#39; + str(j) + &#39;: Shorter than threshold&#39;)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1">#print(&#39;Optional: &#39; + str(opt))</span>
                <span class="n">dif_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">opt</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dif</span><span class="p">))</span>
                <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dif_abs</span><span class="p">)</span>
                <span class="n">ind_min</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif_abs</span> <span class="o">==</span> <span class="n">min_val</span><span class="p">)</span>
                <span class="n">ind_min</span> <span class="o">=</span> <span class="n">ind_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1">#print(&#39;Minimum: &#39; + str(min_val) + &#39;, index: &#39; + str(ind_min))</span>
                <span class="k">if</span> <span class="n">ind_min</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#print(&#39;Original window: &#39; + str(win), end = &#39;&#39;)</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> 
                    <span class="c1">#print(&#39;, modified window: &#39; + str(win))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#print(&#39;Original window: &#39; + str(win), end = &#39;&#39;)</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> 
                    <span class="c1">#print(&#39;, modified window: &#39; + str(win))</span>
                <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dif</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_dif</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1">#print(&#39;IBI pos &#39; + str(j) + &#39;: Longer than threshold&#39;)</span>
                <span class="n">aux_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span><span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">locs_pks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">aux_x</span><span class="p">)</span>
                <span class="c1">#print(&#39;Possible peaks: &#39; + str(locs_pks))</span>
                <span class="c1">#fig = plt.figure()</span>
                <span class="c1">#plt.plot(aux_x)</span>
                <span class="c1">#plt.scatter(locs_pks,aux_x[locs_pks],marker = &#39;o&#39;,color = &#39;red&#39;)</span>
                               
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs_pks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">locs_pks</span> <span class="o">=</span> <span class="n">locs_pks</span> <span class="o">+</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1">#print(&#39;Possible peaks with offset: &#39; + str(locs_pks) + &#39;, amplitudes: &#39; + str(x[locs_pks]) </span>
                    <span class="c1">#     + &#39;, amplitude thresholds: &#39; + str(th_amp))</span>
                    <span class="c1">#ind1, = np.where(x[locs_pks] &gt;= th_amp[0])</span>
                    <span class="c1">#ind2, = np.where(x[locs_pks] &lt;= th_amp[1])</span>
                    <span class="c1">#ind = np.intersect1d(ind1, ind2)</span>
                    <span class="c1">#print(th_amp, locs_pks, ind, dif_abs, locs_pks, win[j])</span>
                    <span class="c1">#locs_pks = locs_pks[ind]</span>
                    <span class="c1">#print(&#39;Locations: &#39; + str(locs_pks))</span>
                
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">locs_pks</span> <span class="o">-</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    
                    <span class="n">dif_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">opt</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dif</span><span class="p">))</span>
                    <span class="c1">#print(dif_abs, opt, locs_pks)</span>
                    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dif_abs</span><span class="p">)</span>
                    <span class="n">ind_min</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif_abs</span> <span class="o">==</span> <span class="n">min_val</span><span class="p">)</span>
                    
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">locs_pks</span><span class="p">[</span><span class="n">ind_min</span><span class="p">])</span>
                    <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>                    
                    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dif</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">opt</span> <span class="o">&lt;</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="c1">#print(win[j], np.median(dif), opt, dif, ind_min, locs_pks)</span>
                        <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                        <span class="n">win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>                  
                        <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">win</span><span class="p">)</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_locs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aux_locs</span> <span class="o">=</span> <span class="n">win</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_locs</span><span class="p">,</span> <span class="n">win</span><span class="p">)</span>
        <span class="n">aux_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">aux_locs</span><span class="p">)</span>
        
        <span class="n">first_i</span> <span class="o">=</span> <span class="n">first_i</span> <span class="o">+</span> <span class="n">stride</span><span class="o">*</span><span class="n">fs</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">second_i</span> <span class="o">=</span> <span class="n">second_i</span> <span class="o">+</span> <span class="n">stride</span><span class="o">*</span><span class="n">fs</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="n">locs</span> <span class="o">=</span> <span class="n">aux_locs</span>

    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span><span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;After length correction&#39;</span><span class="p">)</span>
    
    <span class="c1"># Correction of points that are not peaks</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pre_loc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&#39;Previous: &#39; + str(x[locs[i] - 1]) + &#39;, actual: &#39; + str(x[locs[i]]) + &#39;, next: &#39; + str(x[locs[i] + 1])) </span>
            <span class="n">cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1">#print(&#39;Condition: &#39; + str(cond)) </span>
            <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">pre_loc</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">aux_loc</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">aux_start</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">aux_loc</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">aux_start</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span><span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="n">aux_loc</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">aux_start</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="c1">#print(&#39;i &#39; + str(i) + &#39; out of &#39; + str(len(locs)) + &#39;, aux length: &#39; + str(len(aux)) + </span>
                    <span class="c1">#      &#39;, location: &#39; + str(aux_loc))</span>
                    <span class="c1">#print(&#39;Locs i - 1: &#39; + str(locs[i - 1]) + &#39;, locs i: &#39; + str(locs[i]) + &#39;, locs i + 1: &#39; + str(locs[i + 1]))</span>

                    <span class="n">pre</span> <span class="o">=</span> <span class="n">find_closest_peak</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">aux_loc</span><span class="p">,</span> <span class="s1">&#39;backward&#39;</span><span class="p">)</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">find_closest_peak</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">aux_loc</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">)</span>
                    <span class="c1">#print(&#39;Previous: &#39; + str(pre) + &#39;, next: &#39; + str(pos) + &#39;, actual: &#39; + str(aux_loc))</span>

                    <span class="n">ibi_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pre</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">-</span> <span class="n">pre</span><span class="p">)</span>
                    <span class="n">ibi_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
                    <span class="n">ibi_act</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aux_loc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">-</span> <span class="n">aux_loc</span><span class="p">)</span>
                    <span class="c1">#print(&#39;Previous IBIs: &#39; + str(ibi_pre) + &#39;, next IBIs: &#39; + str(ibi_pos) + </span>
                    <span class="c1">#      &#39;, actual IBIs: &#39; + str(ibi_act))</span>

                    <span class="n">dif_pre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ibi_pre</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">locs</span><span class="p">)))</span>
                    <span class="n">dif_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ibi_pos</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">locs</span><span class="p">)))</span>
                    <span class="n">dif_act</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ibi_act</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">locs</span><span class="p">)))</span>
                    <span class="c1">#print(&#39;Previous DIF: &#39; + str(dif_pre) + &#39;, next DIF: &#39; + str(dif_pos) + </span>
                    <span class="c1">#      &#39;, actual DIF: &#39; + str(dif_act))</span>

                    <span class="n">avgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dif_pre</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dif_pos</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dif_act</span><span class="p">)]</span>
                    <span class="n">min_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">avgs</span><span class="p">)</span>
                    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_avg</span> <span class="o">==</span> <span class="n">avgs</span><span class="p">)</span>
                    <span class="c1">#print(&#39;Averages: &#39; + str(avgs) + &#39;, min index: &#39; + str(ind))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>                        
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pre</span> <span class="o">+</span> <span class="n">aux_start</span> <span class="o">-</span> <span class="mi">1</span>                    
                    <span class="k">elif</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">aux_start</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">ind</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">locs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux_loc</span> <span class="o">+</span> <span class="n">aux_start</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span> 
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span><span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;After not-peak correction&#39;</span><span class="p">)</span>
    
    <span class="c1"># Correction of peaks according to amplitude</span>
    <span class="n">len_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    <span class="c1">#print(&#39;Window length: &#39; + str(len_window))</span>
    <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">first_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">second_i</span> <span class="o">=</span> <span class="n">len_window</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">second_i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;=</span> <span class="n">first_i</span><span class="p">)</span>
        <span class="n">ind2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&lt;=</span> <span class="n">second_i</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">th_amp_low</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
            <span class="n">th_amp_high</span> <span class="o">=</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">th_amp_low</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
            <span class="n">th_amp_high</span> <span class="o">=</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">])</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">th_amp_low</span><span class="p">)</span>
        <span class="n">ind2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">win</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">th_amp_high</span><span class="p">)</span>
        <span class="n">aux_del</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span><span class="n">ind2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_del</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">aux_del</span><span class="p">:</span>
                <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">==</span> <span class="n">win</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">delete</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delete</span><span class="p">,</span> <span class="n">aux_del</span><span class="p">)</span>
                <span class="c1">#print(aux_del, delete)</span>
        
        <span class="n">first_i</span> <span class="o">=</span> <span class="n">second_i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">second_i</span> <span class="o">=</span> <span class="n">second_i</span> <span class="o">+</span> <span class="n">stride</span><span class="o">*</span><span class="n">fs</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span><span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;cyan&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;After amplitude correction&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">#print(delete)</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">delete</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dif</span> <span class="o">&gt;=</span> <span class="n">fs</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">vis</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">locs</span><span class="p">],</span><span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;After amplitude correction&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">locs</span>

<span class="k">def</span> <span class="nf">fiducial_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">pks</span><span class="p">,</span><span class="n">fs</span><span class="p">,</span><span class="n">vis</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Description: Pulse detection and correction from pulsatile signals</span>
<span class="sd">    Inputs:  x, array with pulsatile signal [user defined units]</span>
<span class="sd">             pks, array with the position of the peaks [number of samples]</span>
<span class="sd">             fs, sampling rate of signal [Hz]</span>
<span class="sd">             vis, visualisation option [True, False]</span>
<span class="sd">    Outputs: fidp, dictionary with the positions of several fiducial points for the cardiac cycles [number of samples]</span>
<span class="sd">    </span>
<span class="sd">    Fiducial points:  1: Systolic peak (pks)</span>
<span class="sd">                      2: Onset, as the minimum before the systolic peak (ons)</span>
<span class="sd">                      3: Onset, using the tangent intersection method (ti) </span>
<span class="sd">                      4: Diastolic peak (dpk)</span>
<span class="sd">                      5: Maximum slope (m1d)</span>
<span class="sd">                      6: a point from second derivative PPG (a2d)</span>
<span class="sd">                      7: b point from second derivative PPG (b2d)</span>
<span class="sd">                      8: c point from second derivative PPG (c2d)</span>
<span class="sd">                      9: d point from second derivative PPG (d2d)</span>
<span class="sd">                      10: e point from second derivative PPG (e2d)</span>
<span class="sd">                      11: p1 from the third derivative PPG (p1)    </span>
<span class="sd">                      12: p2 from the third derivative PPG (p2)</span>
<span class="sd">    </span>
<span class="sd">    Libraries: NumPy (as np), SciPy (Signal, as sp), Matplotlib (PyPlot, as plt)</span>
<span class="sd">    </span>
<span class="sd">    Version: 1.0 - June 2022</span>
<span class="sd">    </span>
<span class="sd">    Developed by: Elisa Mejía-Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># First, second and third derivatives</span>
    <span class="n">d1x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">d2x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> 
    <span class="n">d3x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span> 
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x/np.max(x))</span>
    <span class="c1">#plt.plot(d1x/np.max(d1x))</span>
    <span class="c1">#plt.plot(d2x/np.max(d2x))</span>
    <span class="c1">#plt.plot(d3x/np.max(d3x))</span>
    
    <span class="c1"># Search in time series: Onsets between consecutive peaks</span>
    <span class="n">ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ibi</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(ibi, color = &#39;black&#39;)</span>
        <span class="n">aux_ons</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ibi</span><span class="p">))</span>
        <span class="n">ind_ons</span> <span class="o">=</span> <span class="n">aux_ons</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ons</span><span class="p">,</span> <span class="n">ind_ons</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>   
        <span class="c1">#plt.plot(ind_ons, ibi[ind_ons], marker = &#39;o&#39;, color = &#39;red&#39;) </span>
    <span class="n">ons</span> <span class="o">=</span> <span class="n">ons</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#print(&#39;Onsets: &#39; + str(ons))</span>
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x, color = &#39;black&#39;)</span>
    <span class="c1">#plt.scatter(pks, x[pks], marker = &#39;o&#39;, color = &#39;red&#39;) </span>
    <span class="c1">#plt.scatter(ons, x[ons], marker = &#39;o&#39;, color = &#39;blue&#39;) </span>
    
    <span class="c1"># Search in time series: Diastolic peak and dicrotic notch between consecutive onsets</span>
    <span class="n">dia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pks</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pks</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">ind_pks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">ind_pks</span><span class="p">]</span>
            <span class="n">ibi_portion</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind_pks</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="n">ibi_2d_portion</span> <span class="o">=</span> <span class="n">d2x</span><span class="p">[</span><span class="n">ind_pks</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
            <span class="c1">#plt.figure()</span>
            <span class="c1">#plt.plot(ibi_portion/np.max(ibi_portion))</span>
            <span class="c1">#plt.plot(ibi_2d_portion/np.max(ibi_2d_portion))</span>
            <span class="n">aux_dic</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">)</span>
            <span class="n">aux_dic</span> <span class="o">=</span> <span class="n">aux_dic</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">aux_dia</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">ibi_2d_portion</span><span class="p">)</span>
            <span class="n">aux_dia</span> <span class="o">=</span> <span class="n">aux_dia</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>   
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_dic</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ind_max</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_dic</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_dic</span><span class="p">]))</span>
                <span class="n">aux_dic_max</span> <span class="o">=</span> <span class="n">aux_dic</span><span class="p">[</span><span class="n">ind_max</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_dia</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nearest</span> <span class="o">=</span> <span class="n">aux_dia</span> <span class="o">-</span> <span class="n">aux_dic_max</span>
                    <span class="n">aux_dic</span> <span class="o">=</span> <span class="n">aux_dic_max</span>
                    <span class="n">dic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="p">(</span><span class="n">aux_dic</span> <span class="o">+</span> <span class="n">ind_pks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                    <span class="c1">#plt.scatter(aux_dic, ibi_portion[aux_dic]/np.max(ibi_portion), marker = &#39;o&#39;)</span>
                    <span class="n">ind_dia</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nearest</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">aux_dia</span> <span class="o">=</span> <span class="n">aux_dia</span><span class="p">[</span><span class="n">ind_dia</span><span class="p">]</span>
                    <span class="n">nearest</span> <span class="o">=</span> <span class="n">nearest</span><span class="p">[</span><span class="n">ind_dia</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearest</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ind_nearest</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nearest</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nearest</span><span class="p">))</span>
                        <span class="n">aux_dia</span> <span class="o">=</span> <span class="n">aux_dia</span><span class="p">[</span><span class="n">ind_nearest</span><span class="p">]</span>
                        <span class="n">dia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dia</span><span class="p">,</span> <span class="p">(</span><span class="n">aux_dia</span> <span class="o">+</span> <span class="n">ind_pks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                        <span class="c1">#plt.scatter(aux_dia, ibi_portion[aux_dia]/np.max(ibi_portion), marker = &#39;o&#39;)</span>
                        <span class="c1">#break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="p">(</span><span class="n">aux_dic_max</span> <span class="o">+</span> <span class="n">ind_pks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                    <span class="c1">#plt.scatter(aux_dia, ibi_portion[aux_dia]/np.max(ibi_portion), marker = &#39;o&#39;)     </span>
    <span class="n">dia</span> <span class="o">=</span> <span class="n">dia</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#plt.scatter(dia, x[dia], marker = &#39;o&#39;, color = &#39;orange&#39;)</span>
    <span class="c1">#plt.scatter(dic, x[dic], marker = &#39;o&#39;, color = &#39;green&#39;)</span>
    
    <span class="c1"># Search in D1: Maximum slope point</span>
    <span class="n">m1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pks</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pks</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">ind_pks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind_pks</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">ind_pks</span><span class="p">]</span>
            <span class="n">ibi_portion</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">ind_pks</span><span class="p">]</span>
            <span class="n">ibi_1d_portion</span> <span class="o">=</span> <span class="n">d1x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">ind_pks</span><span class="p">]</span>
            <span class="c1">#plt.figure()</span>
            <span class="c1">#plt.plot(ibi_portion/np.max(ibi_portion))</span>
            <span class="c1">#plt.plot(ibi_1d_portion/np.max(ibi_1d_portion))</span>
            <span class="n">aux_m1d</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">ibi_1d_portion</span><span class="p">)</span>
            <span class="n">aux_m1d</span> <span class="o">=</span> <span class="n">aux_m1d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_m1d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ind_max</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_1d_portion</span><span class="p">[</span><span class="n">aux_m1d</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ibi_1d_portion</span><span class="p">[</span><span class="n">aux_m1d</span><span class="p">]))</span>
                <span class="n">aux_m1d_max</span> <span class="o">=</span> <span class="n">aux_m1d</span><span class="p">[</span><span class="n">ind_max</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_m1d_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">aux_m1d_max</span> <span class="o">=</span> <span class="n">aux_m1d_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">m1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m1d</span><span class="p">,</span> <span class="p">(</span><span class="n">aux_m1d_max</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
                <span class="c1">#plt.scatter(aux_m1d, ibi_portion[aux_dic]/np.max(ibi_portion), marker = &#39;o&#39;)</span>
                <span class="c1">#break    </span>
    <span class="n">m1d</span> <span class="o">=</span> <span class="n">m1d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#plt.scatter(m1d, x[m1d], marker = &#39;o&#39;, color = &#39;purple&#39;)</span>
    
    <span class="c1"># Search in time series: Tangent intersection points</span>
    <span class="n">tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ibi_portion</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_1d_portion</span> <span class="o">=</span> <span class="n">d1x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ind_m1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m1d</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m1d</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">))</span>
        <span class="n">ind_m1d</span> <span class="o">=</span> <span class="n">m1d</span><span class="p">[</span><span class="n">ind_m1d</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(ibi_portion/np.max(ibi_portion))</span>
        <span class="c1">#plt.plot(ibi_1d_portion/np.max(ibi_1d_portion))</span>
        <span class="c1">#plt.scatter(ind_m1d, ibi_portion[ind_m1d]/np.max(ibi_portion), marker = &#39;o&#39;)</span>
        <span class="c1">#plt.scatter(ind_m1d, ibi_1d_portion[ind_m1d]/np.max(ibi_1d_portion), marker = &#39;o&#39;)</span>
        <span class="n">aux_tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(((</span><span class="n">ibi_portion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ibi_portion</span><span class="p">[</span><span class="n">ind_m1d</span><span class="p">])</span><span class="o">/</span><span class="n">ibi_1d_portion</span><span class="p">[</span><span class="n">ind_m1d</span><span class="p">])</span> <span class="o">+</span> <span class="n">ind_m1d</span><span class="p">)</span>
        <span class="n">aux_tip</span> <span class="o">=</span> <span class="n">aux_tip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">tip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tip</span><span class="p">,</span> <span class="p">(</span><span class="n">aux_tip</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>        
        <span class="c1">#plt.scatter(aux_tip, ibi_portion[aux_tip]/np.max(ibi_portion), marker = &#39;o&#39;)</span>
        <span class="c1">#break</span>
    <span class="n">tip</span> <span class="o">=</span> <span class="n">tip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#plt.scatter(tip, x[tip], marker = &#39;o&#39;, color = &#39;aqua&#39;)</span>
    
    <span class="c1"># Search in D2: A, B, C, D and E points</span>
    <span class="n">a2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">b2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">c2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">d2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">e2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ibi_portion</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_1d_portion</span> <span class="o">=</span> <span class="n">d1x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_2d_portion</span> <span class="o">=</span> <span class="n">d2x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ind_m1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m1d</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m1d</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">))</span>
        <span class="n">ind_m1d</span> <span class="o">=</span> <span class="n">m1d</span><span class="p">[</span><span class="n">ind_m1d</span><span class="p">]</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(ibi_portion/np.max(ibi_portion))</span>
        <span class="c1">#plt.plot(ibi_1d_portion/np.max(ibi_1d_portion))</span>
        <span class="c1">#plt.plot(ibi_2d_portion/np.max(ibi_2d_portion))</span>
        <span class="n">aux_m2d_pks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">)</span>
        <span class="n">aux_m2d_ons</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">ibi_2d_portion</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_m1d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_m2d_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_m2d_ons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># a point:</span>
            <span class="n">ind_a</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_m2d_pks</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_m2d_pks</span><span class="p">]))</span>
            <span class="n">ind_a</span> <span class="o">=</span> <span class="n">aux_m2d_pks</span><span class="p">[</span><span class="n">ind_a</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind_a</span> <span class="o">&lt;</span> <span class="n">ind_m1d</span><span class="p">):</span>
                <span class="n">a2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a2d</span><span class="p">,</span> <span class="n">ind_a</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                <span class="c1">#plt.scatter(ind_a, ibi_2d_portion[ind_a]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
                <span class="c1"># b point:</span>
                <span class="n">ind_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_m2d_ons</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">aux_m2d_ons</span><span class="p">]))</span>
                <span class="n">ind_b</span> <span class="o">=</span> <span class="n">aux_m2d_ons</span><span class="p">[</span><span class="n">ind_b</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ind_b</span> <span class="o">&gt;</span> <span class="n">ind_a</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind_b</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">)):</span>
                    <span class="n">b2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b2d</span><span class="p">,</span> <span class="n">ind_b</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                    <span class="c1">#plt.scatter(ind_b, ibi_2d_portion[ind_b]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
            <span class="c1"># e point:</span>
            <span class="n">ind_e</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m2d_pks</span> <span class="o">&gt;</span> <span class="n">ind_m1d</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">aux_m2d_pks</span> <span class="o">=</span> <span class="n">aux_m2d_pks</span><span class="p">[</span><span class="n">ind_e</span><span class="p">]</span>
            <span class="n">ind_e</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m2d_pks</span> <span class="o">&lt;</span> <span class="mf">0.6</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">))</span>
            <span class="n">ind_e</span> <span class="o">=</span> <span class="n">aux_m2d_pks</span><span class="p">[</span><span class="n">ind_e</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_e</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_e</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ind_e</span> <span class="o">=</span> <span class="n">ind_e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">e2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e2d</span><span class="p">,</span> <span class="n">ind_e</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                <span class="c1">#plt.scatter(ind_e, ibi_2d_portion[ind_e]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
                <span class="c1"># c point:</span>
                <span class="n">ind_c</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m2d_pks</span> <span class="o">&lt;</span> <span class="n">ind_e</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind_c_aux</span> <span class="o">=</span> <span class="n">aux_m2d_pks</span><span class="p">[</span><span class="n">ind_c</span><span class="p">]</span>
                    <span class="n">ind_c</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">ind_c_aux</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">ind_c_aux</span><span class="p">]))</span>
                    <span class="n">ind_c</span> <span class="o">=</span> <span class="n">ind_c_aux</span><span class="p">[</span><span class="n">ind_c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">c2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c2d</span><span class="p">,</span> <span class="n">ind_c</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                        <span class="c1">#plt.scatter(ind_c, ibi_2d_portion[ind_c]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_m1d_ons</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">ibi_1d_portion</span><span class="p">)</span>
                    <span class="n">ind_c</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m1d_ons</span> <span class="o">&lt;</span> <span class="n">ind_e</span><span class="p">)</span>
                    <span class="n">ind_c_aux</span> <span class="o">=</span> <span class="n">aux_m1d_ons</span><span class="p">[</span><span class="n">ind_c</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ind_c</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ind_c_aux</span> <span class="o">&gt;</span> <span class="n">ind_b</span><span class="p">)</span>
                        <span class="n">ind_c</span> <span class="o">=</span> <span class="n">ind_c_aux</span><span class="p">[</span><span class="n">ind_c</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">ind_c</span> <span class="o">=</span> <span class="n">ind_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">c2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c2d</span><span class="p">,</span> <span class="n">ind_c</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                        <span class="c1">#plt.scatter(ind_c, ibi_2d_portion[ind_c]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
                <span class="c1"># d point:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind_c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m2d_ons</span> <span class="o">&lt;</span> <span class="n">ind_e</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_m2d_ons</span> <span class="o">&gt;</span> <span class="n">ind_c</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ind_d_aux</span> <span class="o">=</span> <span class="n">aux_m2d_ons</span><span class="p">[</span><span class="n">ind_d</span><span class="p">]</span>
                        <span class="n">ind_d</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">ind_d_aux</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ibi_2d_portion</span><span class="p">[</span><span class="n">ind_d_aux</span><span class="p">]))</span>
                        <span class="n">ind_d</span> <span class="o">=</span> <span class="n">ind_d_aux</span><span class="p">[</span><span class="n">ind_d</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">d2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d2d</span><span class="p">,</span> <span class="n">ind_d</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                            <span class="c1">#plt.scatter(ind_d, ibi_2d_portion[ind_d]/np.max(ibi_2d_portion), marker = &#39;o&#39;)                </span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ind_d</span> <span class="o">=</span> <span class="n">ind_c</span>
                        <span class="n">d2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d2d</span><span class="p">,</span> <span class="n">ind_d</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                        <span class="c1">#plt.scatter(ind_d, ibi_2d_portion[ind_d]/np.max(ibi_2d_portion), marker = &#39;o&#39;)</span>
    <span class="n">a2d</span> <span class="o">=</span> <span class="n">a2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">b2d</span> <span class="o">=</span> <span class="n">b2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">c2d</span> <span class="o">=</span> <span class="n">c2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">d2d</span> <span class="o">=</span> <span class="n">d2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">e2d</span> <span class="o">=</span> <span class="n">e2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(d2x, color = &#39;black&#39;)</span>
    <span class="c1">#plt.scatter(a2d, d2x[a2d], marker = &#39;o&#39;, color = &#39;red&#39;) </span>
    <span class="c1">#plt.scatter(b2d, d2x[b2d], marker = &#39;o&#39;, color = &#39;blue&#39;)</span>
    <span class="c1">#plt.scatter(c2d, d2x[c2d], marker = &#39;o&#39;, color = &#39;green&#39;)</span>
    <span class="c1">#plt.scatter(d2d, d2x[d2d], marker = &#39;o&#39;, color = &#39;orange&#39;)</span>
    <span class="c1">#plt.scatter(e2d, d2x[e2d], marker = &#39;o&#39;, color = &#39;purple&#39;)</span>
    
    <span class="c1"># Search in D3: P1 and P2 points</span>
    <span class="n">p1p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">p2p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ibi_portion</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_1d_portion</span> <span class="o">=</span> <span class="n">d1x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_2d_portion</span> <span class="o">=</span> <span class="n">d2x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ibi_3d_portion</span> <span class="o">=</span> <span class="n">d3x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span>
        <span class="n">ind_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b2d</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">b2d</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">))</span>
        <span class="n">ind_b</span> <span class="o">=</span> <span class="n">b2d</span><span class="p">[</span><span class="n">ind_b</span><span class="p">]</span>
        <span class="n">ind_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c2d</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c2d</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">))</span>
        <span class="n">ind_c</span> <span class="o">=</span> <span class="n">c2d</span><span class="p">[</span><span class="n">ind_c</span><span class="p">]</span>
        <span class="n">ind_d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d2d</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d2d</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">))</span>
        <span class="n">ind_d</span> <span class="o">=</span> <span class="n">d2d</span><span class="p">[</span><span class="n">ind_d</span><span class="p">]</span>
        <span class="n">ind_dic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dic</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dic</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">))</span>
        <span class="n">ind_dic</span> <span class="o">=</span> <span class="n">dic</span><span class="p">[</span><span class="n">ind_dic</span><span class="p">]</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(ibi_portion/np.max(ibi_portion))</span>
        <span class="c1">#plt.plot(ibi_1d_portion/np.max(ibi_1d_portion))</span>
        <span class="c1">#plt.plot(ibi_2d_portion/np.max(ibi_2d_portion))</span>
        <span class="c1">#plt.plot(ibi_3d_portion/np.max(ibi_3d_portion))</span>
        <span class="c1">#plt.scatter(ind_b - start, ibi_3d_portion[ind_b - start]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
        <span class="c1">#plt.scatter(ind_c - start, ibi_3d_portion[ind_c - start]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
        <span class="c1">#plt.scatter(ind_d - start, ibi_3d_portion[ind_d - start]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
        <span class="c1">#plt.scatter(ind_dic - start, ibi_3d_portion[ind_dic - start]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
        <span class="n">aux_p3d_pks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">ibi_3d_portion</span><span class="p">)</span>
        <span class="n">aux_p3d_ons</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="o">-</span><span class="n">ibi_3d_portion</span><span class="p">)</span>
        <span class="c1"># P1:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_p3d_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">ind_p1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_p3d_pks</span> <span class="o">&gt;</span> <span class="n">ind_b</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_p1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ind_p1</span> <span class="o">=</span> <span class="n">aux_p3d_pks</span><span class="p">[</span><span class="n">ind_p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">p1p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1p</span><span class="p">,</span> <span class="n">ind_p1</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
                <span class="c1">#plt.scatter(ind_p1, ibi_3d_portion[ind_p1]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
        <span class="c1"># P2:</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aux_p3d_ons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_d</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ind_c</span> <span class="o">==</span> <span class="n">ind_d</span><span class="p">:</span>
                <span class="n">ind_p2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_p3d_ons</span> <span class="o">&gt;</span> <span class="n">ind_d</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">ind_p2</span> <span class="o">=</span> <span class="n">aux_p3d_ons</span><span class="p">[</span><span class="n">ind_p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ind_p2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_p3d_ons</span> <span class="o">&lt;</span> <span class="n">ind_d</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
                <span class="n">ind_p2</span> <span class="o">=</span> <span class="n">aux_p3d_ons</span><span class="p">[</span><span class="n">ind_p2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_dic</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">aux_x_pks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">find_peaks</span><span class="p">(</span><span class="n">ibi_portion</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ind_p2</span> <span class="o">&gt;</span> <span class="n">ind_dic</span> <span class="o">-</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">ind_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_x_pks</span> <span class="o">&lt;</span> <span class="n">ind_p2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_x_pks</span> <span class="o">&gt;</span> <span class="n">ind_dic</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ind_between</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_x_pks</span> <span class="o">&gt;</span> <span class="n">ind_p2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_x_pks</span> <span class="o">&lt;</span> <span class="n">ind_dic</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_between</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ind_p2</span> <span class="o">=</span> <span class="n">aux_x_pks</span><span class="p">[</span><span class="n">ind_between</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">p2p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2p</span><span class="p">,</span> <span class="n">ind_p2</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
            <span class="c1">#plt.scatter(ind_p2, ibi_3d_portion[ind_p2]/np.max(ibi_3d_portion), marker = &#39;o&#39;)</span>
    <span class="n">p1p</span> <span class="o">=</span> <span class="n">p1p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">p2p</span> <span class="o">=</span> <span class="n">p2p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(d3x, color = &#39;black&#39;)</span>
    <span class="c1">#plt.scatter(p1p, d3x[p1p], marker = &#39;o&#39;, color = &#39;green&#39;) </span>
    <span class="c1">#plt.scatter(p2p, d3x[p2p], marker = &#39;o&#39;, color = &#39;orange&#39;)</span>
        
    <span class="k">if</span> <span class="n">vis</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span><span class="n">ax2</span><span class="p">,</span><span class="n">ax3</span><span class="p">,</span><span class="n">ax4</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Fiducial points&#39;</span><span class="p">)</span> 

        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">pks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;pks&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">ons</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">ons</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;ons&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dia</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">dia</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;dia&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">dic</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;dic&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">tip</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">tip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;tip&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>

        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d1x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">m1d</span><span class="p">,</span> <span class="n">d1x</span><span class="p">[</span><span class="n">m1d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;m1d&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;d1x&#39;</span><span class="p">)</span>

        <span class="n">ax3</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d2x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">a2d</span><span class="p">,</span> <span class="n">d2x</span><span class="p">[</span><span class="n">a2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">b2d</span><span class="p">,</span> <span class="n">d2x</span><span class="p">[</span><span class="n">b2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">c2d</span><span class="p">,</span> <span class="n">d2x</span><span class="p">[</span><span class="n">c2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">d2d</span><span class="p">,</span> <span class="n">d2x</span><span class="p">[</span><span class="n">d2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">e2d</span><span class="p">,</span> <span class="n">d2x</span><span class="p">[</span><span class="n">e2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;e&#39;</span><span class="p">)</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;d2x&#39;</span><span class="p">)</span>

        <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">d3x</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;lightgrey&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">p1p</span><span class="p">,</span> <span class="n">d3x</span><span class="p">[</span><span class="n">p1p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;purple&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;p1&#39;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">p2p</span><span class="p">,</span> <span class="n">d3x</span><span class="p">[</span><span class="n">p2p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)],</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">zorder</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;p2&#39;</span><span class="p">)</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;d3x&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                            <span class="n">bottom</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> 
                            <span class="n">right</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> 
                            <span class="n">top</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> 
                            <span class="n">wspace</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> 
                            <span class="n">hspace</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">)</span>
        
    <span class="c1"># Creation of dictionary</span>
    <span class="n">fidp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pks&#39;</span><span class="p">:</span> <span class="n">pks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;ons&#39;</span><span class="p">:</span> <span class="n">ons</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;tip&#39;</span><span class="p">:</span> <span class="n">tip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;dia&#39;</span><span class="p">:</span> <span class="n">dia</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;dic&#39;</span><span class="p">:</span> <span class="n">dic</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;m1d&#39;</span><span class="p">:</span> <span class="n">m1d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;a2d&#39;</span><span class="p">:</span> <span class="n">a2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;b2d&#39;</span><span class="p">:</span> <span class="n">b2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;c2d&#39;</span><span class="p">:</span> <span class="n">c2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;d2d&#39;</span><span class="p">:</span> <span class="n">d2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;e2d&#39;</span><span class="p">:</span> <span class="n">e2d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;p1p&#39;</span><span class="p">:</span> <span class="n">p1p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span>
            <span class="s1">&#39;p2p&#39;</span><span class="p">:</span> <span class="n">p2p</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="k">return</span> <span class="n">fidp</span>

<span class="k">def</span> <span class="nf">find_closest_peak</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">dir_search</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the closest peak to the initial location in x</span>
<span class="sd">    </span>
<span class="sd">    Inputs:   x, signal of interest [user defined units]</span>
<span class="sd">              loc, initial location [number of samples]</span>
<span class="sd">              dir_search, direction of search [&#39;backward&#39;,&#39;forward&#39;]</span>
<span class="sd">    Outputs:  pos, location of the first peak detected in specified direction [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">pos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">dir_search</span> <span class="o">==</span> <span class="s1">&#39;backward&#39;</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">loc</span>
    <span class="k">elif</span> <span class="n">dir_search</span> <span class="o">==</span> <span class="s1">&#39;forward&#39;</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">loc</span>
    
    <span class="k">return</span> <span class="n">pos</span>

<span class="k">def</span> <span class="nf">heartpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">min_ihr</span><span class="p">,</span> <span class="n">max_ihr</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using HeartPy</span>
<span class="sd">    Citation: van Gent P, Farah H, van Nes N, van Arem B (2019) Heartpy: A novel heart rate algorithm</span>
<span class="sd">              for the analysis of noisy signals. Transp Res Part F, vol. 66, pp. 368-378. DOI: 10.1016/j.trf.2019.09.015</span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">              fs, sampling rate [Hz]</span>
<span class="sd">              min_ihr, minimum value of instantaneous heart rate to be accepted [bpm]</span>
<span class="sd">              max_ihr, maximum value of instantaneous heart rate to be accepted [bpm]</span>
<span class="sd">              w, length of segments for correction of peaks [s]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Identification of peaks</span>
    <span class="n">is_roi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_rois</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">len_ma</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">0.75</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="c1">#print(len_ma)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">len_ma</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">len_ma</span><span class="p">))</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="n">len_ma</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="n">len_ma</span><span class="p">:</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">len_ma</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">len_ma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(len(sig[i - len_ma:i + len_ma - 1]),ma)</span>
        
        <span class="c1"># If it is the beginning of a new ROI:    </span>
        <span class="k">if</span> <span class="n">is_roi</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ma</span><span class="p">:</span>    
            <span class="n">is_roi</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">n_rois</span> <span class="o">=</span> <span class="n">n_rois</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1">#print(&#39;New ROI ---&#39; + str(n_rois) + &#39; @ &#39; + str(i))</span>
            <span class="c1"># If it is a peak:</span>
            <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="c1">#print(&#39;Possible peaks: &#39; + str(pos_pks))</span>
           
        <span class="c1"># If it is part of a ROI which is not over: </span>
        <span class="k">elif</span> <span class="n">is_roi</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ma</span><span class="p">:</span>
            <span class="c1">#print(&#39;Actual ROI ---&#39; + str(n_rois) + &#39; @ &#39; + str(i))</span>
            <span class="c1"># If it is a peak:</span>
            <span class="k">if</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="c1">#print(&#39;Possible peaks: &#39; + str(pos_pks))</span>
                
        <span class="c1"># If the ROI is over or the end of the signal has been reached:</span>
        <span class="k">elif</span> <span class="n">is_roi</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ma</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="n">len_ma</span><span class="p">)):</span>
            <span class="c1">#print(&#39;End of ROI ---&#39; + str(n_rois) + &#39; @ &#39; + str(i) + &#39;. Pos pks: &#39; + str(pos_pks))</span>
            <span class="n">is_roi</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Lowers flag</span>
            
            <span class="c1"># If it is the end of the first ROI:</span>
            <span class="k">if</span> <span class="n">n_rois</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If at least one peak has been found: </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Determines the location of the maximum peak:</span>
                    <span class="n">max_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">pos_pks</span><span class="p">])</span>
                    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_pk</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">pos_pks</span><span class="p">]))</span>
                    <span class="c1">#print(&#39;First ROI: (1) Max Peak: &#39; + str(max_pk) + &#39;, amplitudes: &#39; + str(sig[pos_pks]) + </span>
                    <span class="c1">#      &#39;, index: &#39; + str(int(ind)), &#39;, pk_ind: &#39; + str(pos_pks[ind]))</span>
                    <span class="c1"># The maximum peak is added to the list:</span>
                    <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                    <span class="c1">#print(&#39;Locations: &#39; + str(locs))</span>
                <span class="c1"># If no peak was found:</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Counter for ROIs is reset to previous value:</span>
                    <span class="n">n_rois</span> <span class="o">=</span> <span class="n">n_rois</span> <span class="o">-</span> <span class="mi">1</span>
                   
            <span class="c1"># If it is the end of the second ROI:</span>
            <span class="k">elif</span> <span class="n">n_rois</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># If at least one peak has been found:               </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Measures instantantaneous HR of found peaks with respect to the previous peak: </span>
                    <span class="n">ihr</span> <span class="o">=</span> <span class="mi">60</span><span class="o">/</span><span class="p">((</span><span class="n">pos_pks</span> <span class="o">-</span> <span class="n">locs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
                    <span class="n">good_ihr</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ihr</span> <span class="o">&lt;=</span> <span class="n">max_ihr</span> <span class="ow">and</span> <span class="n">ihr</span> <span class="o">&gt;=</span> <span class="n">min_ihr</span><span class="p">)</span>      
                    <span class="c1">#print(&#39;Second ROI IHR check: (1) IHR: &#39; + str(ihr) + &#39;, valid peaks: &#39; + str(good_ihr) + </span>
                    <span class="c1">#      &#39;, pos_pks before: &#39; + str(pos_pks) + &#39;, pos_pks after: &#39; + str(pos_pks[good_ihr]))        </span>
                    <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">good_ihr</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    
                    <span class="c1"># If at least one peak is between HR limits:    </span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Determines the location of the maximum peak:</span>
                        <span class="n">max_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">pos_pks</span><span class="p">])</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_pk</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">pos_pks</span><span class="p">]))</span>
                        <span class="c1">#print(&#39;Second ROI: (1) Max Peak: &#39; + str(max_pk) + &#39;, amplitudes: &#39; + str(sig[pos_pks]) + </span>
                        <span class="c1">#  &#39;, index: &#39; + str(int(ind)), &#39;, pk_ind: &#39; + str(pos_pks[ind]))</span>
                        <span class="c1"># The maximum peak is added to the list:</span>
                        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                        <span class="c1">#print(&#39;Locations: &#39; + str(locs))</span>
                <span class="c1"># If no peak was found:</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Counter for ROIs is reset to previous value:</span>
                    <span class="n">n_rois</span> <span class="o">=</span> <span class="n">n_rois</span> <span class="o">-</span> <span class="mi">1</span>
            
            <span class="c1"># If it is the end of the any further ROI:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If at least one peak has been found: </span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Measures instantantaneous HR of found peaks with respect to the previous peak: </span>
                    <span class="n">ihr</span> <span class="o">=</span> <span class="mi">60</span><span class="o">/</span><span class="p">((</span><span class="n">pos_pks</span> <span class="o">-</span> <span class="n">locs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
                    <span class="n">good_ihr</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ihr</span> <span class="o">&lt;=</span> <span class="n">max_ihr</span> <span class="ow">and</span> <span class="n">ihr</span> <span class="o">&gt;=</span> <span class="n">min_ihr</span><span class="p">)</span> 
                    <span class="c1">#print(&#39;Third ROI IHR check: (1) IHR: &#39; + str(ihr) + &#39;, valid peaks: &#39; + str(good_ihr) + </span>
                    <span class="c1">#      &#39;, pos_pks before: &#39; + str(pos_pks) + &#39;, pos_pks after: &#39; + str(pos_pks[good_ihr]))     </span>
                    <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">good_ihr</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    
                    <span class="c1"># If at least one peak is between HR limits:    </span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Calculates SDNN with the possible peaks on the ROI:</span>
                        <span class="n">sdnn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pos_pks</span><span class="p">)):</span>
                            <span class="n">sdnn</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs</span><span class="o">/</span><span class="n">fs</span><span class="p">,</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">fs</span><span class="p">))</span>
                        <span class="c1"># Determines the new peak as that one with the lowest SDNN:</span>
                        <span class="n">min_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sdnn</span><span class="p">)</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_pk</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sdnn</span><span class="p">))</span>
                        <span class="c1">#print(&#39;Third ROI: (1) Min SDNN Peak: &#39; + str(min_pk) + &#39;, amplitudes: &#39; + str(sig[pos_pks]) + </span>
                        <span class="c1">#  &#39;, index: &#39; + str(int(ind)), &#39;, pk_ind: &#39; + str(pos_pks[ind]))</span>
                        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="n">pos_pks</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                        <span class="c1">#print(&#39;Locations: &#39; + str(locs))</span>
                <span class="c1"># If no peak was found:</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Counter for ROIs is reset to previous value:</span>
                    <span class="n">n_rois</span> <span class="o">=</span> <span class="n">n_rois</span> <span class="o">-</span> <span class="mi">1</span> 
                    
            <span class="c1"># Resets possible peaks for next ROI:            </span>
            <span class="n">pos_pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                           
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="n">locs</span> <span class="o">=</span> <span class="n">locs</span> <span class="o">-</span> <span class="n">len_ma</span>
    
    <span class="c1"># Correction of peaks</span>
    <span class="n">c_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_int</span><span class="p">)):</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
        <span class="c1">#print(&#39;Locs &gt;= &#39; + str((i)*w*fs) + &#39;: &#39; + str(locs[ind1]))</span>
        <span class="n">ind2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
        <span class="c1">#print(&#39;Locs &lt; &#39; + str((i + 1)*w*fs) + &#39;: &#39; + str(locs[ind2]))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>
        <span class="c1">#print(&#39;Larger and lower than locs: &#39; + str(locs[ind]))</span>
        <span class="n">int_locs</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">aux_ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">int_locs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">locs</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">aux_ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">int_locs</span><span class="p">))</span>
        <span class="n">avg_ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">aux_ibis</span><span class="p">)</span>
        <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">avg_ibis</span> <span class="o">-</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">avg_ibis</span><span class="p">),</span> <span class="p">(</span><span class="n">avg_ibis</span> <span class="o">+</span> <span class="mf">0.3</span><span class="o">*</span><span class="n">avg_ibis</span><span class="p">))</span>
        <span class="n">ind1</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_ibis</span> <span class="o">&gt;</span> <span class="n">th</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1">#print(&#39;Ind1: &#39; + str(ind1))</span>
        <span class="n">ind2</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">aux_ibis</span> <span class="o">&lt;</span> <span class="n">th</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#print(&#39;Ind2: &#39; + str(ind2))</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>   
        <span class="c1">#print(&#39;Ind: &#39; + str(ind))     </span>
        
        <span class="n">c_locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_locs</span><span class="p">,</span> <span class="n">int_locs</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">c_locs</span><span class="p">)</span>
    
    <span class="c1">#fig = plt.figure()</span>
    <span class="c1">#plt.plot(x)</span>
    <span class="c1">#plt.plot(sig)</span>
    <span class="c1">#plt.scatter(locs,x[locs],marker = &#39;o&#39;,color = &#39;red&#39;)</span>
    <span class="c1">#if len(c_locs) != 0:</span>
        <span class="c1">#plt.scatter(c_locs,x[c_locs],marker = &#39;o&#39;,color = &#39;blue&#39;)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_locs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ibis</span> <span class="o">=</span> <span class="n">c_locs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ibis</span> <span class="o">=</span> <span class="n">locs</span>
        
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">d2max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using D2Max</span>
<span class="sd">    Citation: Elgendi M, Norton I, Brearley M, Abbott D, Schuurmans D (2013) Systolic Peak Detection in Acceleration</span>
<span class="sd">              Photoplethysmograms Measured from Emergency Responders in Tropical Conditions. PLoS ONE, vol. 8, no. 10, </span>
<span class="sd">              pp. e76585. DOI: 10.1371/journal.pone.0076585</span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">              fs, sampling rate [Hz]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Bandpass filter</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4098</span><span class="p">:</span>
        <span class="n">z_fill</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4098</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z_fill</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_z</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;bp&#39;</span><span class="p">,</span> <span class="n">analog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">x_f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x_z</span><span class="p">)</span>
    
    <span class="c1"># Signal clipping</span>
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">x_c</span> <span class="o">=</span> <span class="n">x_f</span>
    <span class="n">x_c</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># Signal squaring</span>
    <span class="n">x_s</span> <span class="o">=</span> <span class="n">x_c</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x)</span>
    <span class="c1">#plt.plot(x_z)</span>
    <span class="c1">#plt.plot(x_f)</span>
    <span class="c1">#plt.plot(x_c)</span>
    <span class="c1">#plt.plot(x_s)</span>
    
    <span class="c1"># Blocks of interest</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="p">(</span><span class="mf">111e-3</span><span class="p">)</span><span class="o">*</span><span class="n">fs</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">w1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">w1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span>
    <span class="n">ma_pk</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">x_s</span><span class="p">)</span>
    
    <span class="n">w2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">667e-3</span><span class="p">)</span><span class="o">*</span><span class="n">fs</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">w2</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">w2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span>
    <span class="n">ma_bpm</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">x_s</span><span class="p">)</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x_s/np.max(x_s))</span>
    <span class="c1">#plt.plot(ma_pk/np.max(ma_pk))</span>
    <span class="c1">#plt.plot(ma_bpm/np.max(ma_bpm))</span>
    
    <span class="c1"># Thresholding</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.02</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ma_pk</span><span class="p">)</span>
    <span class="n">th_1</span> <span class="o">=</span> <span class="n">ma_bpm</span> <span class="o">+</span> <span class="n">alpha</span>
    <span class="n">th_2</span> <span class="o">=</span> <span class="n">w1</span>
    <span class="n">boi</span> <span class="o">=</span> <span class="p">(</span><span class="n">ma_pk</span> <span class="o">&gt;</span> <span class="n">th_1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="n">blocks_init</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">boi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">blocks_init</span> <span class="o">=</span> <span class="n">blocks_init</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">blocks_end</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">boi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">blocks_end</span> <span class="o">=</span> <span class="n">blocks_end</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">blocks_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">blocks_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">blocks_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">blocks_init</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">blocks_init</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">blocks_end</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">blocks_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">blocks_end</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_s</span><span class="p">))</span>
    <span class="c1">#print(&#39;Initial locs BOI: &#39; + str(blocks_init))</span>
    <span class="c1">#print(&#39;Final locs BOI: &#39; + str(blocks_end))</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x_s[range(len(x))]/np.max(x_s))</span>
    <span class="c1">#plt.plot(boi[range(len(x))])</span>
    
    <span class="c1"># Search for peaks inside BOIs</span>
    <span class="n">len_blks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocks_init</span><span class="p">))</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocks_init</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocks_init</span><span class="p">)):</span>
        <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">blocks_end</span> <span class="o">&gt;</span> <span class="n">blocks_init</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">len_blks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">blocks_end</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">blocks_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">len_blks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">th_2</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">blocks_init</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">blocks_end</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
                <span class="n">max_ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">max_val</span> <span class="o">==</span> <span class="n">aux</span><span class="p">)</span>
                <span class="n">ibis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_ind</span> <span class="o">+</span> <span class="n">blocks_init</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">len_blks</span> <span class="o">&lt;</span> <span class="n">th_2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
            <span class="n">boi</span><span class="p">[</span><span class="n">blocks_init</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">blocks_end</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>    
    <span class="n">ind</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ibis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">ibis</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="c1">#plt.plot(boi[range(len(x))])</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x)</span>
    <span class="c1">#plt.scatter(ibis, x[ibis], marker = &#39;o&#39;,color = &#39;red&#39;)</span>
    
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">upslopes</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using Upslopes</span>
<span class="sd">    Citation: Arguello Prada EJ, Serna Maldonado RD (2018) A novel and low-complexity peak detection algorithm for </span>
<span class="sd">              heart rate estimation from low-amplitude photoplethysmographic (PPG) signals. J Med Eng Technol, vol. 42, </span>
<span class="sd">              no. 8, pp. 569-577. DOI: 10.1080/03091902.2019.1572237</span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Peak detection</span>
    <span class="n">th</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pos_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pos_pk_b</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_pos_pk</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_up</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">n_up</span> <span class="o">=</span> <span class="n">n_up</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_up</span> <span class="o">&gt;</span> <span class="n">th</span><span class="p">:</span>
                <span class="n">pos_pk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos_pk</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">pos_pk_b</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">n_pos_pk</span> <span class="o">=</span> <span class="n">n_pos_pk</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">n_up_pre</span> <span class="o">=</span> <span class="n">n_up</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pos_pk</span> <span class="o">=</span> <span class="n">pos_pk</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1">#print(&#39;Possible peaks: &#39; + str(pos_pk) + &#39;, number of peaks: &#39; + str(n_pos_pk))</span>
                <span class="k">if</span> <span class="n">pos_pk_b</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">pos_pk</span><span class="p">[</span><span class="n">n_pos_pk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]:</span>
                        <span class="n">pos_pk</span><span class="p">[</span><span class="n">n_pos_pk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">pos_pk</span><span class="p">[</span><span class="n">n_pos_pk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">th</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">n_up_pre</span>
                    <span class="n">pos_pk_b</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_up</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">pks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#print(ibis)</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x)</span>
    <span class="c1">#plt.scatter(ibis, x[ibis], marker = &#39;o&#39;,color = &#39;red&#39;)</span>
    
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">bishop</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using Bishop&#39;s beat detector</span>
<span class="sd">    Citation: Bishop SM, Ercole A (2018) Multi-scale peak and trough detection optimised</span>
<span class="sd">                for periodic and quasi-periodic neuroscience data. doi:10.1007/978-3-319-65798-1_39</span>
<span class="sd">    Source: This implementation is from ppg_findpeaks in Neurokit2</span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Peter H. Charlton</span>
<span class="sd">    Version:       0.1 -   March, 2023</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Setup</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Step 1: calculate local maxima and local minima scalograms</span>

    <span class="c1"># - detrend: this removes the best-fit straight line</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>

    <span class="c1"># - initialise LMS matrices</span>
    <span class="n">m_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">m_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># - populate LMS matrices</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>  <span class="c1"># scalogram scales</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">m_max</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">m_min</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Step 2: find the scale with the most local maxima (or local minima)</span>
    <span class="c1"># - row-wise summation (i.e. sum each row)</span>
    <span class="n">gamma_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m_max</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># the &quot;axis=1&quot; option makes it row-wise</span>
    <span class="n">gamma_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># - find scale with the most local maxima (or local minima)</span>
    <span class="n">lambda_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gamma_max</span><span class="p">)</span>
    <span class="n">lambda_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">gamma_min</span><span class="p">)</span>

    <span class="c1"># Step 3: Use lambda to remove all elements of m for which k&gt;lambda</span>
    <span class="n">m_max</span> <span class="o">=</span> <span class="n">m_max</span><span class="p">[:</span> <span class="p">(</span><span class="n">lambda_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
    <span class="n">m_min</span> <span class="o">=</span> <span class="n">m_min</span><span class="p">[:</span> <span class="p">(</span><span class="n">lambda_min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>

    <span class="c1"># Step 4: Find peaks (and onsets)</span>
    <span class="c1"># - column-wise summation</span>
    <span class="n">m_max_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m_max</span> <span class="o">==</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m_min_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m_min</span> <span class="o">==</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">peaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m_max_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m_min_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">peaks</span>

<span class="k">def</span> <span class="nf">qppg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">fs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using qppg</span>
<span class="sd">    Citation: Vest AN et al. An open source benchmarked toolbox for cardiovascular waveform</span>
<span class="sd">              and interval analysis. Physiological Measurement. 2018;39(10).</span>
<span class="sd">              https://doi.org/10.1088/1361-6579/aae021</span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">              fs, sampling rate [Hz]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Peter H. Charlton</span>
<span class="sd">    Version:       0.1 -   March, 2023 (doesn&#39;t seem to be working yet)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Setup</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">uniform_filter1d</span>
    <span class="n">show</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">x</span>
    
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">__</span><span class="p">,</span> <span class="n">ax0</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ax0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;signal&quot;</span><span class="p">)</span>

    <span class="c1"># Specify constants (where periods are specified in seconds)</span>
    <span class="n">r_period</span> <span class="o">=</span> <span class="mf">0.34</span> <span class="c1"># Refractory period (aka eye-closing period) of</span>
    <span class="n">l_period</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># Learning period</span>
    <span class="n">s_period</span> <span class="o">=</span> <span class="mf">0.17</span> <span class="c1"># slope period</span>
    <span class="n">maxrr_period</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="c1"># max inter-beat interval </span>
    <span class="n">re_scale_period</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="mi">60</span> <span class="c1"># duration of windows over which to perform re-scaling</span>
    
    <span class="c1"># Re-scale input signal to occupy a range of +/- 2000</span>
    <span class="c1"># - find min and max for each re-scale period</span>
    <span class="n">win_durn_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">re_scale_period</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="n">win_starts</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">win_durn_samps</span><span class="p">)</span>
    <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">win_no</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">win_starts</span><span class="p">)):</span>
        <span class="n">last_el</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span><span class="o">+</span><span class="n">win_durn_samps</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">win_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">],</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">),</span> <span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span><span class="o">+</span><span class="n">win_durn_samps</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">mins</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="p">:</span> <span class="n">last_el</span><span class="p">])</span>
        <span class="n">maxs</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">win_starts</span><span class="p">[</span><span class="n">win_no</span><span class="p">]</span> <span class="p">:</span> <span class="n">last_el</span><span class="p">])</span>
    <span class="c1"># - calculate average min and max over whole signal</span>
    <span class="n">mins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">maxs</span><span class="p">)</span>
    <span class="c1"># - re-scale</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="mi">4000</span><span class="o">*</span><span class="p">(</span><span class="n">signal</span><span class="o">-</span><span class="n">mins</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">maxs</span><span class="o">-</span><span class="n">mins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2000</span>
    
    <span class="c1"># Calculate sum of slopes function (SSF)</span>
    <span class="c1"># - calculate no of samples in slope period</span>
    <span class="n">s_period_samps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">s_period</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
    <span class="c1"># - calculate slopes</span>
    <span class="n">deriv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="c1"># - rectify</span>
    <span class="n">deriv</span><span class="p">[</span><span class="n">deriv</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># - calculate sum of slopes function</span>
    <span class="n">ssf</span> <span class="o">=</span> <span class="n">uniform_filter1d</span><span class="p">(</span><span class="n">deriv</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">s_period_samps</span><span class="p">))</span> <span class="c1"># this is a moving average</span>

    <span class="c1"># Learning</span>
    <span class="c1"># - calculate mean SSF during learning period</span>
    <span class="n">l_period_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">l_period</span><span class="o">*</span><span class="n">fs</span><span class="p">)))</span>
    <span class="c1"># - check there is sufficient input signal</span>
    <span class="k">if</span> <span class="n">l_period_els</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Input signal needs to be at least 8 seconds long&#39;</span><span class="p">)</span>
    <span class="n">mean_ssf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">l_period_els</span><span class="p">])</span>
    
    <span class="c1"># - set initial values of thresholds</span>
    <span class="n">th_adapt</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">mean_ssf</span> <span class="c1"># adaptive threshold</span>
    <span class="n">th_ssf</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">mean_ssf</span> <span class="c1"># threshold for identifying beats in SSF</span>
    
    <span class="c1"># Identify peaks</span>
    <span class="c1"># - constants</span>
    <span class="n">maxrr_period_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">maxrr_period</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="n">r_period_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">r_period</span><span class="o">*</span><span class="n">fs</span><span class="p">))</span>
    <span class="n">half_r_period_samps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">r_period_samps</span><span class="p">))</span>
    <span class="c1"># - initialise variables</span>
    <span class="n">samps_since_peak</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># - cycle through each sample</span>
    <span class="n">onsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">el</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">el</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">-</span><span class="n">r_period_samps</span><span class="p">:</span>
        
        <span class="n">el</span> <span class="o">=</span> <span class="n">el</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">samps_since_peak</span> <span class="o">=</span> <span class="n">samps_since_peak</span><span class="o">+</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">el</span> <span class="o">&gt;</span> <span class="n">l_period_els</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ssf</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">th_ssf</span><span class="p">:</span>
            <span class="c1"># - if not in the learning period and not above SSF threshold</span>
            <span class="k">if</span> <span class="n">samps_since_peak</span> <span class="o">&gt;</span> <span class="n">maxrr_period_samps</span><span class="p">:</span>
                <span class="n">th_adapt</span> <span class="o">=</span> <span class="n">th_adapt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="n">th_ssf</span> <span class="o">=</span> <span class="n">th_adapt</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
        <span class="k">elif</span> <span class="n">ssf</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">th_ssf</span><span class="p">:</span> <span class="c1"># above SSF threshold</span>
            <span class="c1"># - search for the max SSF within the eye-closing period after the current index</span>
            <span class="n">search_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">ssf</span><span class="p">),</span> <span class="n">el</span><span class="o">+</span><span class="n">r_period_samps</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">rel_max_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">search_els</span><span class="p">]</span><span class="o">==</span><span class="nb">max</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">search_els</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># - if this maximum is at the current point then ignore (and continue) because it is on the downslope</span>
            
            <span class="k">if</span> <span class="n">rel_max_el</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">max_el</span> <span class="o">=</span> <span class="n">rel_max_el</span> <span class="o">+</span> <span class="n">el</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># - search for the location of the minimum SSF value in the time period (of duration half the eye-closing period) preceeding this maximum.</span>
            <span class="n">first_el</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">el</span><span class="o">-</span><span class="n">half_r_period_samps</span><span class="p">)</span>
            <span class="n">search_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_el</span><span class="p">,</span><span class="n">el</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">rel_min_el</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">search_els</span><span class="p">]</span><span class="o">==</span><span class="nb">min</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">search_els</span><span class="p">]))[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">min_el</span> <span class="o">=</span> <span class="n">search_els</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">rel_min_el</span>
            
            <span class="c1"># - if the max SSF is more than 10 more than the min, then:</span>
            <span class="k">if</span> <span class="n">ssf</span><span class="p">[</span><span class="n">max_el</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="n">ssf</span><span class="p">[</span><span class="n">min_el</span><span class="p">]):</span>
                <span class="c1"># - locate the pulse onset as the minimum within the refractory period before this point</span>
                <span class="n">first_el</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_el</span><span class="o">-</span><span class="n">half_r_period_samps</span><span class="p">)</span>
                <span class="n">search_els</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_el</span><span class="p">,</span> <span class="n">max_el</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">min_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">search_els</span><span class="p">])</span>
                <span class="n">onsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">search_els</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">signal</span><span class="p">[</span><span class="n">search_els</span><span class="p">]</span><span class="o">==</span><span class="n">min_val</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
                <span class="c1"># Adjust the thresholds:</span>
                <span class="c1"># - (i) add on to the adaptive threshold one tenth of the difference between the max SSF value and the current adaptive threshold;</span>
                <span class="n">th_adapt</span> <span class="o">=</span> <span class="n">th_adapt</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="n">ssf</span><span class="p">[</span><span class="n">max_el</span><span class="p">]</span><span class="o">-</span><span class="n">th_adapt</span><span class="p">)</span>
                <span class="c1"># - (ii) set th_ssf to one third of the adaptive threshold.</span>
                <span class="n">th_ssf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">th_adapt</span>
                
                <span class="c1"># skip samples in the refractory period, i.e.</span>
                <span class="n">el</span> <span class="o">=</span> <span class="n">max_el</span><span class="o">+</span><span class="n">r_period_samps</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">samps_since_peak</span> <span class="o">=</span> <span class="n">r_period_samps</span>
    
    <span class="n">onsets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># remove the first element which was used to initiate the variable</span>
    
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">ax0</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">onsets</span><span class="p">,</span> <span class="n">signal</span><span class="p">[</span><span class="n">onsets</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

    <span class="n">onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">onsets</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">onsets</span>
    
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">delineator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detects inter-beat intervals using Delineator</span>
<span class="sd">    Citation: Li BN, Dong MC, Vai MI (2010) On an automatic delineator for arterial blood pressure waveforms. Biomed</span>
<span class="sd">    Signal Process Control, vol. 5, no. 1, pp. 76-81. DOI: 10.1016/j.bspc.2009.06.002 </span>

<span class="sd">    Inputs:   x, pulsatile signal [user defined units]</span>
<span class="sd">              fs, sampling rate [Hz]</span>
<span class="sd">    Outputs:  ibis, position of the starting points of inter-beat intervals [number of samples]</span>
<span class="sd"> </span>
<span class="sd">    Developed by:  Elisa Mejía Mejía</span>
<span class="sd">                   City, University of London</span>
<span class="sd">    Version:       1.0 -   June, 2022</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
       
    <span class="c1"># Lowpass filter</span>
    <span class="n">od</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">sos</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="n">od</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">btype</span> <span class="o">=</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="n">analog</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;sos&#39;</span><span class="p">,</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">x_f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sosfiltfilt</span><span class="p">(</span><span class="n">sos</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">x_m</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="n">x_f</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x)</span>
    <span class="c1">#plt.plot(x_f)</span>
    <span class="c1">#plt.plot(x_m)</span>
    
    <span class="c1"># Moving average</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">x_ma</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">x_m</span><span class="p">)</span>
        
    <span class="c1"># Compute differentials</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x_ma</span><span class="p">)</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="mi">100</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dif</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dif</span><span class="p">)</span>
    <span class="n">dif_ma</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">dif</span><span class="p">)</span>
    
    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(x_ma)</span>
    <span class="c1">#plt.plot(dif_ma)</span>
               
    <span class="c1"># Average thresholds in original signal</span>
    <span class="n">x_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_len</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="o">*</span><span class="n">fs</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">elif</span> <span class="n">x_len</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="o">*</span><span class="n">fs</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">elif</span> <span class="n">x_len</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="o">*</span><span class="n">fs</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#print(n)</span>
    
    <span class="n">max_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(x_ma)</span>
        <span class="n">n_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x_len</span><span class="o">/</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1">#print(&#39;Length of intervals: &#39; + str(n_int))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># Searches for max and min in 1 s intervals</span>
            <span class="n">amp_min</span><span class="p">,</span> <span class="n">ind_min</span><span class="p">,</span> <span class="n">amp_max</span><span class="p">,</span> <span class="n">ind_max</span> <span class="o">=</span> <span class="n">seek_local</span><span class="p">(</span><span class="n">x_ma</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">n_int</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">n_int</span> <span class="o">+</span> <span class="n">fs</span><span class="p">))</span>  
            <span class="c1">#plt.scatter(ind_min, amp_min, marker = &#39;o&#39;, color = &#39;red&#39;)</span>
            <span class="c1">#plt.scatter(ind_max, amp_max, marker = &#39;o&#39;, color = &#39;green&#39;)</span>
            <span class="n">max_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_min</span><span class="p">,</span> <span class="p">(</span><span class="n">amp_max</span> <span class="o">-</span> <span class="n">amp_min</span><span class="p">))</span>
        <span class="n">max_min_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">max_min</span><span class="p">)</span>
        <span class="c1">#print(&#39;Local max and min: &#39; + str(max_min) + &#39;, average amplitude: &#39; + str(max_min_avg))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">amp_min</span><span class="p">,</span> <span class="n">ind_min</span> <span class="p">,</span> <span class="n">amp_max</span><span class="p">,</span> <span class="n">ind_max</span> <span class="o">=</span> <span class="n">seek_local</span><span class="p">(</span><span class="n">x_ma</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">close_win</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_len</span><span class="p">))</span>
        <span class="c1">#plt.figure()</span>
        <span class="c1">#plt.plot(x_ma) </span>
        <span class="c1">#plt.scatter(ind_min, amp_min, marker = &#39;o&#39;, color = &#39;red&#39;)</span>
        <span class="c1">#plt.scatter(ind_max, amp_max, marker = &#39;o&#39;, color = &#39;green&#39;)</span>
        <span class="n">max_min_avg</span> <span class="o">=</span> <span class="n">amp_max</span> <span class="o">-</span> <span class="n">amp_min</span>
        <span class="c1">#print(&#39;Local max and min: &#39; + str(max_min) + &#39;, average amplitude: &#39; + str(max_min_avg))</span>
        
    <span class="n">max_min_lt</span> <span class="o">=</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">max_min_avg</span>
    
    <span class="c1"># Seek pulse beats by min-max method</span>
    <span class="n">step_win</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">fs</span>       <span class="c1"># Window length to look for peaks/onsets</span>
    <span class="n">close_win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">fs</span><span class="p">)</span>
                          <span class="c1"># Value of what is considered too close</span>
    
    <span class="n">pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>     <span class="c1"># Location of peaks</span>
    <span class="n">ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>     <span class="c1"># Location of onsets</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>     <span class="c1"># Location of dicrotic notches</span>
        
    <span class="n">pk_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># Number of peaks found</span>
    <span class="n">on_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># Number of onsets found</span>
    <span class="n">dn_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>          <span class="c1"># Number of dicrotic notches found</span>
    
    <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">close_win</span><span class="p">)</span>    <span class="c1"># Initializes counter</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x_len</span><span class="p">:</span>      <span class="c1"># Iterates through the signal</span>
        <span class="c1">#print(&#39;i: &#39; + str(i))</span>
        <span class="n">amp_min</span> <span class="o">=</span> <span class="n">x_ma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># Gets the initial value for the minimum amplitude</span>
        <span class="n">amp_max</span> <span class="o">=</span> <span class="n">x_ma</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># Gets the initial value for the maximum amplitude</span>
        
        <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>           <span class="c1"># Initializes the temporal location of the index</span>
        <span class="n">aux_pks</span> <span class="o">=</span> <span class="n">i</span>       <span class="c1"># Initializes the temporal location of the peak </span>
        <span class="n">aux_ons</span> <span class="o">=</span> <span class="n">i</span>       <span class="c1"># Initializes the temporal location of the onset</span>
        
        <span class="c1"># Iterates while ind is lower than the length of the signal</span>
        <span class="k">while</span> <span class="n">ind</span> <span class="o">&lt;</span> <span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#print(&#39;Ind: &#39; + str(ind))</span>
            <span class="c1"># Verifies if no peak has been found in 2 seconds</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">step_win</span><span class="p">:</span>
                <span class="c1">#print(&#39;Peak not found in 2 s&#39;)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>   <span class="c1"># Refreshes the temporal location of the index</span>
                <span class="n">max_min_avg</span> <span class="o">=</span> <span class="mf">0.6</span><span class="o">*</span><span class="n">max_min_avg</span>  <span class="c1"># Refreshes the threshold for the amplitude</span>
                <span class="c1"># Verifies if the threshold is lower than the lower limit</span>
                <span class="k">if</span> <span class="n">max_min_avg</span> <span class="o">&lt;=</span> <span class="n">max_min_lt</span><span class="p">:</span>
                    <span class="n">max_min_avg</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">*</span><span class="n">max_min_lt</span> <span class="c1"># Refreshes the threshold</span>
                <span class="k">break</span>
            
            <span class="c1"># Verifies if the location is a candidate peak </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dif_ma</span><span class="p">[</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dif_ma</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#print(&#39;There is a candidate peak&#39;)</span>
                <span class="c1"># Determines initial and end points of a window to search for local peaks and onsets</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">x_len</span><span class="p">:</span>
                    <span class="n">i_stop</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i_stop</span> <span class="o">=</span> <span class="n">x_len</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i_start</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">-</span> <span class="mi">5</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i_start</span> <span class="o">=</span> <span class="mi">0</span>
                
                <span class="c1"># Checks for artifacts of saturated or signal loss</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i_stop</span> <span class="o">-</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">i_stop</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">dif_ma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i_stop</span><span class="p">:</span>
                        <span class="c1">#print(&#39;Artifact&#39;)</span>
                        <span class="k">break</span>
                        
                <span class="c1"># Candidate onset</span>
                <span class="c1">#print(&#39;Looking for candidate onsets...&#39;)</span>
                <span class="c1">#plt.figure()</span>
                <span class="c1">#plt.plot(x_ma)</span>
                <span class="k">if</span> <span class="n">dif_ma</span><span class="p">[</span><span class="n">i_start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dif_ma</span><span class="p">[</span><span class="n">i_stop</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">aux_min</span><span class="p">,</span> <span class="n">ind_min</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">seek_local</span><span class="p">(</span><span class="n">x_ma</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_stop</span><span class="p">))</span>
                        <span class="c1">#plt.scatter(ind_min, aux_min, marker = &#39;o&#39;, color = &#39;red&#39;)</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ind_min</span> <span class="o">-</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">amp_min</span> <span class="o">=</span> <span class="n">aux_min</span>
                            <span class="n">aux_ons</span> <span class="o">=</span> <span class="n">ind_min</span>
                <span class="c1">#print(&#39;Candidate onset: &#39; + str([ind_min, amp_min]))</span>
                <span class="c1"># Candidate peak</span>
                <span class="c1">#print(&#39;Looking for candidate peaks...&#39;)</span>
                <span class="k">if</span> <span class="n">dif_ma</span><span class="p">[</span><span class="n">i_start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dif_ma</span><span class="p">[</span><span class="n">i_stop</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">aux_max</span><span class="p">,</span> <span class="n">ind_max</span> <span class="o">=</span> <span class="n">seek_local</span><span class="p">(</span><span class="n">x_ma</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_start</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">i_stop</span><span class="p">))</span>
                        <span class="c1">#plt.scatter(ind_max, aux_max, marker = &#39;o&#39;, color = &#39;green&#39;)</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ind_max</span> <span class="o">-</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">amp_max</span> <span class="o">=</span> <span class="n">aux_max</span>
                            <span class="n">aux_pks</span> <span class="o">=</span> <span class="n">ind_max</span>
                <span class="c1">#print(&#39;Candidate peak: &#39; + str([ind_max, amp_max]))</span>
                <span class="c1"># Verifies if the amplitude of the pulse is larger than 0.4 times the mean value:</span>
                <span class="c1">#print(&#39;Pulse amplitude: &#39; + str(amp_max - amp_min) + &#39;, thresholds: &#39; + </span>
                <span class="c1">#      str([0.4*max_min_avg, 2*max_min_avg]))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">amp_max</span> <span class="o">-</span> <span class="n">amp_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.4</span><span class="o">*</span><span class="n">max_min_avg</span><span class="p">:</span>
                    <span class="c1">#print(&#39;Expected amplitude of pulse&#39;)</span>
                    <span class="c1"># Verifies if the amplitude of the pulse is lower than 2 times the mean value:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">amp_max</span> <span class="o">-</span> <span class="n">amp_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">max_min_avg</span><span class="p">:</span>
                        <span class="c1">#print(&#39;Expected duration of pulse&#39;)</span>
                        <span class="k">if</span> <span class="n">aux_pks</span> <span class="o">&gt;</span> <span class="n">aux_ons</span><span class="p">:</span>
                            <span class="c1">#print(&#39;Refining onsets...&#39;)</span>
                            <span class="c1"># Refine onsets:</span>
                            <span class="n">aux_min</span> <span class="o">=</span> <span class="n">x_ma</span><span class="p">[</span><span class="n">aux_ons</span><span class="p">]</span>
                            <span class="n">temp_ons</span> <span class="o">=</span> <span class="n">aux_ons</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">aux_pks</span><span class="p">,</span> <span class="n">aux_ons</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">x_ma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">aux_min</span><span class="p">:</span>
                                    <span class="n">aux_min</span> <span class="o">=</span> <span class="n">x_ma</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                                    <span class="n">temp_ons</span> <span class="o">=</span> <span class="n">j</span>
                            <span class="n">amp_min</span> <span class="o">=</span> <span class="n">aux_min</span>
                            <span class="n">aux_ons</span> <span class="o">=</span> <span class="n">temp_ons</span>
                            
                            <span class="c1"># If there is at least one peak found before:</span>
                            <span class="c1">#print(&#39;Number of previous peaks: &#39; + str(pk_index + 1))</span>
                            <span class="k">if</span> <span class="n">pk_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#print(&#39;There were previous peaks&#39;)</span>
                                <span class="c1">#print(&#39;Duration of ons to peak interval: &#39; + str(aux_ons - pks[pk_index]) + </span>
                                <span class="c1">#     &#39;, threshold: &#39; + str([3*close_win, step_win]))</span>
                                <span class="c1"># If the duration of the pulse is too short:</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">aux_ons</span> <span class="o">-</span> <span class="n">pks</span><span class="p">[</span><span class="n">pk_index</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">close_win</span><span class="p">:</span>
                                    <span class="c1">#print(&#39;Too short interbeat interval&#39;)</span>
                                    <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
                                    <span class="n">max_min_avg</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">*</span><span class="n">max_min_lt</span>
                                    <span class="k">break</span>
                                <span class="c1"># If the time difference between consecutive peaks is longer:    </span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">aux_pks</span> <span class="o">-</span> <span class="n">pks</span><span class="p">[</span><span class="n">pk_index</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">step_win</span><span class="p">:</span>
                                    <span class="c1">#print(&#39;Too long interbeat interval&#39;)</span>
                                    <span class="n">pk_index</span> <span class="o">=</span> <span class="n">pk_index</span> <span class="o">-</span> <span class="mi">1</span>
                                    <span class="n">on_index</span> <span class="o">=</span> <span class="n">on_index</span> <span class="o">-</span> <span class="mi">1</span>
                                    <span class="c1">#if dn_index &gt; 0:</span>
                                    <span class="c1">#    dn_index = dn_index - 1</span>
                                <span class="c1"># If there are still peaks, add the new peak:</span>
                                <span class="k">if</span> <span class="n">pk_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="c1">#print(&#39;There are still previous peaks&#39;)</span>
                                    <span class="n">pk_index</span> <span class="o">=</span> <span class="n">pk_index</span> <span class="o">+</span> <span class="mi">1</span>
                                    <span class="n">on_index</span> <span class="o">=</span> <span class="n">on_index</span> <span class="o">+</span> <span class="mi">1</span>
                                    <span class="n">pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">aux_pks</span><span class="p">)</span>
                                    <span class="n">ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ons</span><span class="p">,</span> <span class="n">aux_ons</span><span class="p">)</span>
                                    <span class="c1">#print(&#39;Peaks: &#39; + str(pks))</span>
                                    <span class="c1">#print(&#39;Onsets: &#39; + str(ons))   </span>
                                    
                                    <span class="n">tf</span> <span class="o">=</span> <span class="n">ons</span><span class="p">[</span><span class="n">pk_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">ons</span><span class="p">[</span><span class="n">pk_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                                    
                                    <span class="n">to</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
                                    <span class="n">tff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">tf</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">tff</span> <span class="o">&lt;</span> <span class="n">to</span><span class="p">:</span>
                                        <span class="n">to</span> <span class="o">=</span> <span class="n">tff</span>
                                    <span class="n">to</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">pk_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">to</span>
                                    
                                    <span class="n">te</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
                                    <span class="n">tff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">tf</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="n">tff</span> <span class="o">&lt;</span> <span class="n">te</span><span class="p">:</span>
                                        <span class="n">te</span> <span class="o">=</span> <span class="n">tff</span>
                                    <span class="n">te</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">pk_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">te</span>
                                    
                                    <span class="c1">#tff = seek_dicrotic(dif_ma[to:te])</span>
                                    <span class="c1">#if tff == 0:</span>
                                    <span class="c1">#    tff = te - pks[pk_index - 1]</span>
                                    <span class="c1">#    tff = np.floor(tff/3)</span>
                                    <span class="c1">#dn_index = dn_index + 1</span>
                                    <span class="c1">#dic[dn_index] = to + tff</span>
                                    
                                    <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">close_win</span>
                                    <span class="k">break</span>
                            <span class="c1"># If it is the first peak:</span>
                            <span class="k">if</span> <span class="n">pk_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1">#print(&#39;There were no previous peaks&#39;)</span>
                                <span class="n">pk_index</span> <span class="o">=</span> <span class="n">pk_index</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">on_index</span> <span class="o">=</span> <span class="n">on_index</span> <span class="o">+</span> <span class="mi">1</span>
                                <span class="n">pks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pks</span><span class="p">,</span> <span class="n">aux_pks</span><span class="p">)</span>
                                <span class="n">ons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ons</span><span class="p">,</span> <span class="n">aux_ons</span><span class="p">)</span>
                                <span class="c1">#print(&#39;Peaks: &#39; + str(pks))</span>
                                <span class="c1">#print(&#39;Onsets: &#39; + str(ons))                                </span>
                                <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="n">close_win</span>
                                <span class="k">break</span>
                                
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks</span><span class="p">)</span>
        <span class="n">temp_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_len</span><span class="p">):</span>
            <span class="n">temp_p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_p</span><span class="p">,</span> <span class="n">pks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">od</span><span class="p">)</span>
        <span class="n">ttk</span> <span class="o">=</span> <span class="n">temp_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttk</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">temp_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pks</span> <span class="o">=</span> <span class="n">temp_p</span>
        
        <span class="n">x_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ons</span><span class="p">)</span>
        <span class="n">temp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_len</span><span class="p">):</span>
            <span class="n">temp_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp_o</span><span class="p">,</span> <span class="n">ons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">od</span><span class="p">)</span>
        <span class="n">ttk</span> <span class="o">=</span> <span class="n">temp_o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ttk</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">temp_o</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ons</span> <span class="o">=</span> <span class="n">temp_o</span>
               
    <span class="n">pks</span> <span class="o">=</span> <span class="n">pks</span> <span class="o">+</span> <span class="mi">5</span>
    <span class="n">ibis</span> <span class="o">=</span> <span class="n">pks</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ibis</span>

<span class="k">def</span> <span class="nf">seek_dicrotic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    
    <span class="n">izc_min</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">izc_max</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_temp</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">temp_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
    
    <span class="n">dic_notch</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>
    
    <span class="n">tzc_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i_temp</span> <span class="o">&lt;=</span> <span class="n">temp_len</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i_temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">izc_min</span> <span class="o">=</span> <span class="n">izc_min</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">tzc_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tzc_min</span><span class="p">,</span> <span class="n">i_temp</span><span class="p">)</span>
        <span class="n">i_temp</span> <span class="o">=</span> <span class="n">i_temp</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">izc_min</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">i_temp</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">temp_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span>
        <span class="n">i_temp_min</span> <span class="o">=</span> <span class="n">i_temp</span>
        <span class="k">while</span> <span class="n">i_temp</span> <span class="o">&lt;</span> <span class="n">temp_len</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">dic_notch</span> <span class="o">=</span> <span class="n">i_temp</span>
                <span class="k">return</span> <span class="n">dic_notch</span>
            <span class="n">i_temp</span> <span class="o">=</span> <span class="n">i_temp</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">izc_min</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dic_notch</span> <span class="o">=</span> <span class="n">tzc_min</span><span class="p">[</span><span class="n">izc_min</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dic_notch</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i_temp</span> <span class="o">=</span> <span class="n">tzc_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">temp_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span>
        <span class="n">i_temp_max</span> <span class="o">=</span> <span class="n">i_temp</span>
        <span class="k">while</span> <span class="n">i_temp</span> <span class="o">&lt;</span> <span class="n">temp_len</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp_max</span><span class="p">:</span>
                <span class="n">temp_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span>
                <span class="n">i_temp_max</span> <span class="o">=</span> <span class="n">i_temp</span>
            <span class="n">i_temp</span> <span class="o">=</span> <span class="n">i_temp</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i_temp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">izc_min</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tzc_min</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_temp_max</span><span class="p">:</span>
                <span class="n">dic_notch</span> <span class="o">=</span> <span class="n">tzc_min</span><span class="p">[</span><span class="n">i_temp</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">dic_notch</span>
    
    <span class="k">return</span> <span class="n">dic_notch</span>

<span class="k">def</span> <span class="nf">seek_local</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
    <span class="n">val_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">val_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>
    
    <span class="n">ind_min</span> <span class="o">=</span> <span class="n">start</span>
    <span class="n">ind_max</span> <span class="o">=</span> <span class="n">start</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val_max</span><span class="p">:</span>
            <span class="n">val_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ind_max</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">elif</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">val_min</span><span class="p">:</span>
            <span class="n">val_min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ind_min</span> <span class="o">=</span> <span class="n">j</span>
    
    <span class="k">return</span> <span class="n">val_min</span><span class="p">,</span> <span class="n">ind_min</span><span class="p">,</span> <span class="n">val_max</span><span class="p">,</span> <span class="n">ind_max</span>
</pre></div>
</div>
</div>
</div>
<p>Now return to <a class="reference external" href="#detect-beats-in-the-PPG-signal">this step</a></p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./tutorial/notebooks"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="beat-detection.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Beat detection</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="pulse-wave-analysis.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Pulse Wave Analysis</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Peter H Charlton and [the team](https://github.com/peterhcharlton/bsp-book#contributors-)<br/>
        
            &copy; Copyright 2023.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
    
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>


    
  </body>
</html>